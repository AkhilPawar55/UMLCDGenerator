/* Generated By:JavaCC: Do not edit this line. Parser.java */
import java.util.*;
public class Parser implements ParserConstants {

/** 	specification ::= [module] open* paragraph*
*/
  static final public Specification Sp() throws ParseException {
                     Exp e1; Exp e2; Specification e3; Exp e4; Exp e5;
         e3 = new Specification();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MODULE:
      e1 = ModuleDecl();
                            e3.setModule(e1);
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
      Sp1();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THIS:
      case OPEN:
      case SOME:
      case ONE:
      case LONE:
      case FACT:
      case ASSERT:
      case FUNCTION:
      case PREDICATE:
      case RUN:
      case CHECK:
      case ENUM:
      case SIGNATURE:
      case ABSTRACT:
      case ID:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      e2 = Sp2();
                      if(e2.getClass() == BinaryExp.class)
                                        {
                                                e3.addOpenDecl(e2);
                                        }
                                else{
                                                e3.addParagraph(e2);
                                        }
    }
    jj_consume_token(0);
               {if (true) return e3;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp Sp1() throws ParseException {
            Exp e;
    e = QualDecl();
                        {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp Sp2() throws ParseException {
            Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN:
      e = OpenDecl();
                        {if (true) return e;}
      break;
    case THIS:
    case SOME:
    case ONE:
    case LONE:
    case FACT:
    case ASSERT:
    case FUNCTION:
    case PREDICATE:
    case RUN:
    case CHECK:
    case ENUM:
    case SIGNATURE:
    case ABSTRACT:
    case ID:
      e = Paragraph();
                         {if (true) return e;}
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/** 	paragraph ::= factDecl | assertDecl | funDecl | cmdDecl | enumDecl | sigDecl
*/
  static final public Exp Paragraph() throws ParseException {
                  Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FACT:
      e = FactDecl();
                        {if (true) return e;}
      break;
    case PREDICATE:
      e = PredDecl();
                        {if (true) return e;}
      break;
    case ASSERT:
      e = AssertDecl();
                          {if (true) return e;}
      break;
    case FUNCTION:
      e = FunDecl();
                       {if (true) return e;}
      break;
    case THIS:
    case RUN:
    case CHECK:
    case ID:
      e = CommandDecl();
                           {if (true) return e;}
      break;
    case ENUM:
      e = EnumDecl();
                        {if (true) return e;}
      break;
    case SOME:
    case ONE:
    case LONE:
    case SIGNATURE:
    case ABSTRACT:
      e = SignatureDecl();
                             {if (true) return e;}
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/** 	module ::= "module" name  [ "["  ["exactly"] name  ("," ["exactly"] num)*    "]" ]
*/
  static final public Exp ModuleDecl() throws ParseException {
                   Exp e1; Exp e2;
    e1 = Module();
    e2 = ModuleNameBracket();
                                                e1 = new ModuleDeclaration(""+e2);
                                                                                     {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ModuleNameBracket() throws ParseException {
                          Exp e1; Exp e2;
    e1 = QualName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      e2 = ModuleBracket();
                                               e1 = new BinaryExp(e2, e1, e2);
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
                                                                                   {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

/** 	name ::= ("this" | ID) ["/" ID]*
*/
  static final public Exp QualName() throws ParseException {
                 Exp e1; Exp e2; Exp e3; Exp e4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THIS:
      e1 = ThisDecl();
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STROKE:
          ;
          break;
        default:
          jj_la1[6] = jj_gen;
          break label_2;
        }
        e2 = StrokeDecl();
                                            e1 = new BinaryExp(e2, e1, e2);
        e2 = IdentifierDecl();
                                                                                                    e1 = new BinaryExp(e2, e1, e2);
      }
                                                                                                                                        {if (true) return e1;}
      break;
    case ID:
      e1 = IdentifierDecl();
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STROKE:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_3;
        }
        e2 = StrokeDecl();
                                                  e1 = new BinaryExp(e2, e1, e2);
        e3 = IdentifierDecl();
                                                                                                          e1 = new BinaryExp(e2, e1, e3);
      }
                                                                                                                                              {if (true) return e1;}
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp StrokeDecl() throws ParseException {
                   Token n;
    n = jj_consume_token(STROKE);
                      {if (true) return new Stroke(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp IdentifierDecl() throws ParseException {
                       Token n;
    n = jj_consume_token(ID);
                  {if (true) return new Id(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ThisDecl() throws ParseException {
                 Token n;
    n = jj_consume_token(THIS);
                    {if (true) return new This(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp Module() throws ParseException {
               Token n;
    n = jj_consume_token(MODULE);
                      {if (true) return new Module(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ModuleBracket() throws ParseException {
                      Exp e1; Exp e2; Exp e3; Exp e4;
    e3 = LBracketDecl();
    label_4:
    while (true) {
      e1 = ExactlyDecl();
      e2 = IdentifierDecl();
      e4 = RBracketDecl();
                                                                                           e1 = new BinaryExp(e3, e1, e2);
                                                                                                                             {if (true) return e1;}
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXACTLY:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_4;
      }
    }
    e2 = IdentifierDecl();
    e4 = RBracketDecl();
                                                                                                                                                                                       {if (true) return e2;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp LBracketDecl() throws ParseException {
                     Token n;
    n = jj_consume_token(LBRACKET);
                        {if (true) return new LBracket(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp RBracketDecl() throws ParseException {
                     Token n;
    n = jj_consume_token(RBRACKET);
                        {if (true) return new RBracket(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ExactlyDecl() throws ParseException {
                    Token n;
    n = jj_consume_token(EXACTLY);
                       {if (true) return new Exactly(n.image);}
    throw new Error("Missing return statement in function");
  }

/** 	open ::= ["private"]  "open"  name  [ "[" ref,+ "]" ]  [ "as" name ]
*/
  static final public Exp OpenDecl() throws ParseException {
                 Exp e1; Exp e2;
    e2 = OpenNameDecl();
                             {if (true) return e2;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp OpenNameDecl() throws ParseException {
                     Exp e1; Exp e2; Exp e3; Exp e4;
    e1 = OpenSymDecl();
    e2 = QualName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      e3 = OpenRefDecl();
                                                                e1 = new BinaryExp(e1, e1, e3);
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AS:
      e4 = OpenAlias();
                                                                                                                      e1 = new BinaryExp(e4, e1, e4);
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
                                                                                                                                                          {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp OpenSymDecl() throws ParseException {
                    Token n;
    n = jj_consume_token(OPEN);
                    {if (true) return new Open(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp OpenRefDecl() throws ParseException {
                    Exp e1; Exp e2; Exp e3; Exp e4;
    e1 = LBracketDecl();
    label_5:
    while (true) {
      e2 = RefName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[12] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THIS:
      case UNIV:
      case INT:
      case SEQINT:
      case ID:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_5;
      }
    }
    e4 = RBracketDecl();
                                                                          {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

/** 	ref ::= name | "univ" | "Int" | "seq/Int"
*/
  static final public Exp RefName() throws ParseException {
                Exp e1; Exp e2; Exp e3; Exp e4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THIS:
    case ID:
      e1 = QualName();
                         {if (true) return e1;}
      break;
    case UNIV:
      e2 = UnivSymDecl();
                            {if (true) return e2;}
      break;
    case INT:
      e3 = IntSymDecl();
                           {if (true) return e3;}
      break;
    case SEQINT:
      e4 = SeqIntSymDecl();
                              {if (true) return e4;}
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp CommaDecl() throws ParseException {
                  Token n;
    n = jj_consume_token(COMMA);
                     {if (true) return new Comma(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp UnivSymDecl() throws ParseException {
                    Token n;
    n = jj_consume_token(UNIV);
                    {if (true) return new Univ(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp IntSymDecl() throws ParseException {
                   Token n;
    n = jj_consume_token(INT);
                   {if (true) return new Int(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp SeqIntSymDecl() throws ParseException {
                      Token n;
    n = jj_consume_token(SEQINT);
                      {if (true) return new Seqint(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp OpenAlias() throws ParseException {
                  Exp e1; Exp e2;
    e1 = AsSymDecl();
    e2 = QualName();
                                          e1 = new BinaryExp(e1, e1, e2);
                                                                            {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp AsSymDecl() throws ParseException {
                  Token n;
    n = jj_consume_token(AS);
                  {if (true) return new As(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp QualDecl() throws ParseException {
                 Token n;
    n = jj_consume_token(PRIVATE);
                       {if (true) return new Private(n.image);}
    throw new Error("Missing return statement in function");
  }

/** 	compareOp ::= "=" | "in" | "<" | ">" | "=<" | ">="
*/
  static final public Exp CompareOpDecl() throws ParseException {
                      Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQSIGN:
      e = EqualSignDecl();
                             {if (true) return e;}
      break;
    case INCLUSION:
      e = InclusionDecl();
                             {if (true) return e;}
      break;
    case LESSER:
      e = LesserDecl();
                          {if (true) return e;}
      break;
    case GREATER:
      e = GreaterDecl();
                           {if (true) return e;}
      break;
    case LESSEROREQUAL:
      e = LesserOrEqualDecl();
                                 {if (true) return e;}
      break;
    case GREATEROREQUAL:
      e = GreaterOrEqualDecl();
                                  {if (true) return e;}
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp EqualSignDecl() throws ParseException {
                      Token n;
    n = jj_consume_token(EQSIGN);
                      {if (true) return new EqualSign(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp InclusionDecl() throws ParseException {
                      Token n;
    n = jj_consume_token(INCLUSION);
                         {if (true) return new Inclusion(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp LesserDecl() throws ParseException {
                   Token n;
    n = jj_consume_token(LESSER);
                      {if (true) return new Lesser(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp GreaterDecl() throws ParseException {
                    Token n;
    n = jj_consume_token(GREATER);
                       {if (true) return new Greater(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp LesserOrEqualDecl() throws ParseException {
                          Token n;
    n = jj_consume_token(LESSEROREQUAL);
                             {if (true) return new LesserOrEqual(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp GreaterOrEqualDecl() throws ParseException {
                           Token n;
    n = jj_consume_token(GREATEROREQUAL);
                              {if (true) return new GreaterOrEqual(n.image);}
    throw new Error("Missing return statement in function");
  }

/** 	arrowOp ::= ["some"|"one"|"lone"|"set"] "->" ["some"|"one"|"lone"|"set"]
*/
  static final public Exp ArrowOpDecl() throws ParseException {
                    Exp e1; Exp e2; Exp e3; ArrowOpExp e4;
         e4 = new ArrowOpExp();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SOME:
    case ONE:
    case LONE:
    case SET:
      e1 = ArrowArity();
                            e4.setLeft(e1);
      break;
    default:
      jj_la1[16] = jj_gen;
      ;
    }
    e2 = ArrowOpSymDecl();
                               e4.setArrow(e2);
    if (jj_2_1(2)) {
      e3 = ArrowArity();
                                         e4.setRight(e3);
    } else {
      ;
    }
                                                              {if (true) return e4;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ArrowOpSymDecl() throws ParseException {
                       Token n;
    n = jj_consume_token(ARROW);
                     {if (true) return new Arrow(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ArrowArity() throws ParseException {
                   Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SOME:
      e = SomeSymDecl();
                           {if (true) return e;}
      break;
    case ONE:
      e = OneSymDecl();
                          {if (true) return e;}
      break;
    case LONE:
      e = LoneSymDecl();
                           {if (true) return e;}
      break;
    case SET:
      e = SetSymDecl();
                          {if (true) return e;}
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp SomeSymDecl() throws ParseException {
                    Token n;
    n = jj_consume_token(SOME);
                    {if (true) return new Some(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp OneSymDecl() throws ParseException {
                   Token n;
    n = jj_consume_token(ONE);
                   {if (true) return new One(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp LoneSymDecl() throws ParseException {
                    Token n;
    n = jj_consume_token(LONE);
                    {if (true) return new Lone(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp SetSymDecl() throws ParseException {
                   Token n;
    n = jj_consume_token(SET);
                   {if (true) return new Set(n.image);}
    throw new Error("Missing return statement in function");
  }

/** 	binOp ::= "||" | "or" | "&&" | "and" | "&" | "<=>" | "iff"
        | "=>" | "implies" | "+" | "-" | "++" | "<:" | ":>" | "." | "<<" | ">>" | ">>>"
*/
  static final public Exp BinOpDecl() throws ParseException {
                  Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AND:
      e = AndDecl();
                       {if (true) return e;}
      break;
    case OR:
      e = OrDecl();
                      {if (true) return e;}
      break;
    case DOUBLEIMPLIES:
      e = DoubleImplicationDecl();
                                     {if (true) return e;}
      break;
    case IFF:
      e = IffDecl();
                       {if (true) return e;}
      break;
    case PLUS:
      e = PlusDecl();
                        {if (true) return e;}
      break;
    case MINUS:
      e = MinusDecl();
                         {if (true) return e;}
      break;
    case PLUSPLUS:
      e = PlusPlusDecl();
                            {if (true) return e;}
      break;
    case DOMAINRESTRICTION:
      e = DomainRestrictionDecl();
                                     {if (true) return e;}
      break;
    case RANGERESTRICTION:
      e = RangeRestrictionDecl();
                                    {if (true) return e;}
      break;
    case DOT:
      e = DotDecl();
                       {if (true) return e;}
      break;
    case LEFTSHIFT:
      e = LeftShiftDecl();
                             {if (true) return e;}
      break;
    case RIGHTSHIFT:
      e = RightShiftDecl();
                              {if (true) return e;}
      break;
    case UNSIGNEDRIGHTSHIFT:
      e = UnsignedRightShiftDecl();
                                      {if (true) return e;}
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp AndDecl() throws ParseException {
                Token n;
    n = jj_consume_token(AND);
                   {if (true) return new And(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp OrDecl() throws ParseException {
               Token n;
    n = jj_consume_token(OR);
                  {if (true) return new Or(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp DoubleImplicationDecl() throws ParseException {
                              Token n;
    n = jj_consume_token(DOUBLEIMPLIES);
                             {if (true) return new DoubleImplication (n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp IffDecl() throws ParseException {
                Token n;
    n = jj_consume_token(IFF);
                   {if (true) return new Iff(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ImpliesDecl() throws ParseException {
                    Token n;
    n = jj_consume_token(IMPLIES);
                       {if (true) return new Implies(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp PlusDecl() throws ParseException {
                 Token n;
    n = jj_consume_token(PLUS);
                    {if (true) return new Plus(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp MinusDecl() throws ParseException {
                  Token n;
    n = jj_consume_token(MINUS);
                     {if (true) return new Minus(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp PlusPlusDecl() throws ParseException {
                     Token n;
    n = jj_consume_token(PLUSPLUS);
                        {if (true) return new PlusPlus(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp DomainRestrictionDecl() throws ParseException {
                              Token n;
    n = jj_consume_token(DOMAINRESTRICTION);
                                 {if (true) return new DomainRestriction(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp RangeRestrictionDecl() throws ParseException {
                             Token n;
    n = jj_consume_token(RANGERESTRICTION);
                                {if (true) return new RangeRestriction(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp DotDecl() throws ParseException {
                Token n;
    n = jj_consume_token(DOT);
                   {if (true) return new Dot(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp LeftShiftDecl() throws ParseException {
                      Token n;
    n = jj_consume_token(LEFTSHIFT);
                         {if (true) return new LeftShift(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp RightShiftDecl() throws ParseException {
                       Token n;
    n = jj_consume_token(RIGHTSHIFT);
                          {if (true) return new RightShift(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp UnsignedRightShiftDecl() throws ParseException {
                               Token n;
    n = jj_consume_token(UNSIGNEDRIGHTSHIFT);
                                  {if (true) return new UnsignedRightShift(n.image);}
    throw new Error("Missing return statement in function");
  }

/** 	unOp ::= "!" | "not" | "no" | "some" | "lone" | "one" | "set" | "seq" | "#" | "~" | "*" | "^"
*/
  static final public Exp UnOpDecl() throws ParseException {
                 Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
      e = BangDecl();
                        {if (true) return e;}
      break;
    case SET:
      e = SetSymDecl();
                          {if (true) return e;}
      break;
    case SEQ:
      e = SeqDecl();
                       {if (true) return e;}
      break;
    case POUND:
      e = PoundDecl();
                         {if (true) return e;}
      break;
    case TILDE:
      e = TildeDecl();
                         {if (true) return e;}
      break;
    case REFLEXIVETRASITIVECLOSURE:
      e = ReflexiveTransitiveClosureDecl();
                                              {if (true) return e;}
      break;
    case NONREFLEXIVETRASITIVECLOSURE:
      e = NonReflexiveTransitiveClosureDecl();
                                                 {if (true) return e;}
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp BangDecl() throws ParseException {
                 Token n;
    n = jj_consume_token(BANG);
                    {if (true) return new Bang(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp NotDecl() throws ParseException {
                Token n;
    n = jj_consume_token(NOT);
                   {if (true) return new Not(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp NoDecl() throws ParseException {
               Token n;
    n = jj_consume_token(NO);
                  {if (true) return new No(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp SeqDecl() throws ParseException {
                Token n;
    n = jj_consume_token(SEQ);
                   {if (true) return new Seq(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp PoundDecl() throws ParseException {
                  Token n;
    n = jj_consume_token(POUND);
                     {if (true) return new Pound(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp TildeDecl() throws ParseException {
                  Token n;
    n = jj_consume_token(TILDE);
                     {if (true) return new Tilde(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ReflexiveTransitiveClosureDecl() throws ParseException {
                                       Token n;
    n = jj_consume_token(REFLEXIVETRASITIVECLOSURE);
                                         {if (true) return new ReflexiveTransitiveClosure(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp NonReflexiveTransitiveClosureDecl() throws ParseException {
                                          Token n;
    n = jj_consume_token(NONREFLEXIVETRASITIVECLOSURE);
                                            {if (true) return new NonReflexiveTransitiveClosure(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp QuantDecl() throws ParseException {
                  Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ALL:
      e = AllDecl();
                       {if (true) return e;}
      break;
    case SUM:
      e = SumDecl();
                       {if (true) return e;}
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp AllDecl() throws ParseException {
                Token n;
    n = jj_consume_token(ALL);
                   {if (true) return new All(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp SumDecl() throws ParseException {
                Token n;
    n = jj_consume_token(SUM);
                   {if (true) return new Sum(n.image);}
    throw new Error("Missing return statement in function");
  }

/** LetDecl ::= name "=" expr 
*/
  static final public Exp LetDecl() throws ParseException {
                Let e1; Exp e2; Exp e3; Exp e4;
         e1 = new Let();
    e2 = QualName();
                                           e1.setName(e2);
    e3 = EqualSignDecl();
                                                                                  e1.setOp(e3);
    e4 = ExprDeclE();
                                                                                                                   e1.setExpr(e4);
                                                                                                                                     {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

/** DeclDecl ::= ["private"] ["disj"] name,+ ":" ["disj"] expr */
  static final public Exp DeclDecl() throws ParseException {
                 Decl e1; Exp e2; Exp e3; Exp e4; Exp e5; Exp e6; Exp e7;Exp e8; Exp e9;
         e1 = new Decl();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PRIVATE:
      e2 = QualDecl();
                                             e1.setQualifier(e2);
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISJOINT:
      e3 = DisjDecl();
                                                                                       e1.setDisjName(e3);
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
    e4 = QualName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THIS:
      case ID:
        ;
        break;
      default:
        jj_la1[24] = jj_gen;
        break label_6;
      }
      e8 = QualName();
                                                 e4 = new UnaryExp(e4, e8);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[25] = jj_gen;
        ;
      }
    }
                                                                                       e1.setName(e4);
    e5 = ColonDecl();
                                                                                                                          e1.setOp(e5);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DISJOINT:
      e6 = DisjDecl();
                                                                                                                                                           e1.setDisjName(e5);
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    e7 = ExprDeclE();
                          e1.setExpr(e7);
                                            {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ColonDecl() throws ParseException {
                  Token n;
    n = jj_consume_token(COLON);
                     {if (true) return new Colon(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp DisjDecl() throws ParseException {
                 Token n;
    n = jj_consume_token(DISJOINT);
                        {if (true) return new Disjoint(n.image);}
    throw new Error("Missing return statement in function");
  }

/** BlockOrBarDecl ::= block | "|" expr */
  static final public Exp BlockOrBarDecl() throws ParseException {
                       BlockOrBar e1; Exp e2; Exp e3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BAR:
                      e1 = new BlockOrBar();
      e2 = BarDecl();
      e3 = ExprDeclE();
                                                                               e1.setBar(e2, e3);
                                                                                                    {if (true) return e1;}
      break;
    case LCURLY:
                  e1 = new BlockOrBar();
      e2 = BlockDecl();
                                                            e1.setBlock(e2);
                                                                               {if (true) return e1;}
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp BarDecl() throws ParseException {
                Token n;
    n = jj_consume_token(BAR);
                   {if (true) return new Bar(n.image);}
    throw new Error("Missing return statement in function");
  }

/** BlockDecl ::= "{" expr* "}" */
  static final public Exp BlockDecl() throws ParseException {
                  Block e1; Exp e2; Exp e3; Exp e4;
         e1 = new Block();
    jj_consume_token(LCURLY);
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUM:
      case THIS:
      case UNIV:
      case INT:
      case SEQINT:
      case LBRACKET:
      case EQSIGN:
      case INCLUSION:
      case LESSER:
      case GREATER:
      case LESSEROREQUAL:
      case GREATEROREQUAL:
      case SOME:
      case ONE:
      case LONE:
      case SET:
      case OR:
      case AND:
      case DOUBLEIMPLIES:
      case IFF:
      case IMPLIES:
      case PLUS:
      case MINUS:
      case PLUSPLUS:
      case DOMAINRESTRICTION:
      case RANGERESTRICTION:
      case DOT:
      case LEFTSHIFT:
      case RIGHTSHIFT:
      case UNSIGNEDRIGHTSHIFT:
      case BANG:
      case NOT:
      case NO:
      case SEQ:
      case POUND:
      case TILDE:
      case REFLEXIVETRASITIVECLOSURE:
      case NONREFLEXIVETRASITIVECLOSURE:
      case ALL:
      case SUM:
      case LCURLY:
      case LET:
      case IDEN:
      case LPAREN:
      case AT:
      case NONE:
      case ID:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_7;
      }
      e3 = ExprDeclE();
                            e1.setExpr(e3);
    }
    jj_consume_token(RCURLY);
             {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp LcurlyDecl() throws ParseException {
                   Token n;
    n = jj_consume_token(LCURLY);
                      {if (true) return new Lcurly(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp RcurlyDecl() throws ParseException {
                   Token n;
    n = jj_consume_token(RCURLY);
                      {if (true) return new Rcurly(n.image);}
    throw new Error("Missing return statement in function");
  }

/**
		expr ::= "let" letDecl,+ blockOrBar
       | quant decl,+    blockOrBar
       | unOp expr
       | expr binOp   expr
       | expr arrowOp expr
       | expr ["!"|"not"] compareOp expr
       | expr ("=>"|"implies") expr "else" expr
       | expr "[" expr,* "]"
       |     number
       | "-" number
       | "none"
       | "iden"
       | "univ"
       | "Int"
       | "seq/Int"
       | "(" expr ")"
       | ["@"] name
       | block
       | "{" decl,+ blockOrBar "}"
*/
  static final public Exp ExprDeclE() throws ParseException {
                  Exp e1; Exp e2; Exp e3;
    e1 = B();
    label_8:
    while (true) {
      if (jj_2_2(2)) {
        ;
      } else {
        break label_8;
      }
      e2 = OrDecl();
      e3 = B();
                                                       e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                         {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp B() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = C();
    label_9:
    while (true) {
      if (jj_2_3(2)) {
        ;
      } else {
        break label_9;
      }
      e2 = DoubleImplicationDecl();
      e3 = C();
                                                                      e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                                        {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp C() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = D();
    label_10:
    while (true) {
      if (jj_2_4(2)) {
        ;
      } else {
        break label_10;
      }
      e2 = CC();
      e3 = D();
                                                   e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                     {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp CC() throws ParseException {
           Exp e1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLIES:
      e1 = ImpliesDecl();
                            {if (true) return e1;}
      break;
    case ELSE:
      e1 = ElseDecl();
                         {if (true) return e1;}
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp D() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = E();
    label_11:
    while (true) {
      if (jj_2_5(2)) {
        ;
      } else {
        break label_11;
      }
      e2 = AndDecl();
      e3 = E();
                                                        e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                          {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp E() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = F();
    label_12:
    while (true) {
      if (jj_2_6(2)) {
        ;
      } else {
        break label_12;
      }
      e2 = BangDecl();
      e3 = F();
                                                         e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                           {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp F() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = G();
    label_13:
    while (true) {
      if (jj_2_7(2)) {
        ;
      } else {
        break label_13;
      }
      e2 = FF();
      e3 = G();
                                                   e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                     {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp FF() throws ParseException {
           Exp e1; Exp e2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCLUSION:
      e1 = InclusionDecl();
                              {if (true) return e1;}
      break;
    case EQSIGN:
      e1 = EqualSignDecl();
                              {if (true) return e1;}
      break;
    case LESSER:
      e1 = LesserDecl();
                           {if (true) return e1;}
      break;
    case GREATER:
      e1 = GreaterDecl();
                            {if (true) return e1;}
      break;
    case LESSEROREQUAL:
      e1 = LesserOrEqualDecl();
                                  {if (true) return e1;}
      break;
    case GREATEROREQUAL:
      e1 = GreaterOrEqualDecl();
                                   {if (true) return e1;}
      break;
    case BANG:
      e1 = BangDecl();
      e2 = FFF();
                                    e1 = new UnaryExp(e1,e2);
                                                                {if (true) return e1;}
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp FFF() throws ParseException {
            Exp e1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INCLUSION:
      e1 = InclusionDecl();
                              {if (true) return e1;}
      break;
    case EQSIGN:
      e1 = EqualSignDecl();
                              {if (true) return e1;}
      break;
    case LESSER:
      e1 = LesserDecl();
                           {if (true) return e1;}
      break;
    case GREATER:
      e1 = GreaterDecl();
                            {if (true) return e1;}
      break;
    case LESSEROREQUAL:
      e1 = LesserOrEqualDecl();
                                  {if (true) return e1;}
      break;
    case GREATEROREQUAL:
      e1 = GreaterOrEqualDecl();
                                   {if (true) return e1;}
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp G() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = H();
    label_14:
    while (true) {
      if (jj_2_8(2)) {
        ;
      } else {
        break label_14;
      }
      e2 = GG();
      e3 = H();
                                                   e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                     {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp GG() throws ParseException {
           Exp e1; Exp e2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LEFTSHIFT:
      e1 = LeftShiftDecl();
                              {if (true) return e1;}
      break;
    case RIGHTSHIFT:
      e1 = RightShiftDecl();
                               {if (true) return e1;}
      break;
    case UNSIGNEDRIGHTSHIFT:
      e1 = UnsignedRightShiftDecl();
                                       {if (true) return e1;}
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp H() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = I();
    label_15:
    while (true) {
      if (jj_2_9(2)) {
        ;
      } else {
        break label_15;
      }
      e2 = HH();
      e3 = I();
                                                   e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                     {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp HH() throws ParseException {
           Exp e1; Exp e2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      e1 = PlusDecl();
                         {if (true) return e1;}
      break;
    case MINUS:
      e1 = MinusDecl();
                          {if (true) return e1;}
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp I() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = J();
    label_16:
    while (true) {
      if (jj_2_10(2)) {
        ;
      } else {
        break label_16;
      }
      e2 = PoundDecl();
      e3 = J();
                                                          e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                            {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp J() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = K();
    label_17:
    while (true) {
      if (jj_2_11(2)) {
        ;
      } else {
        break label_17;
      }
      e2 = PlusPlusDecl();
      e3 = K();
                                                             e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                               {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp K() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = L();
    label_18:
    while (true) {
      if (jj_2_12(2)) {
        ;
      } else {
        break label_18;
      }
      e2 = AndDecl();
      e3 = L();
                                                        e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                          {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp L() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = M();
    label_19:
    while (true) {
      if (jj_2_13(2)) {
        ;
      } else {
        break label_19;
      }
      e2 = ArrowOpDecl();
      e3 = M();
                                                            e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                              {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp M() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = N();
    label_20:
    while (true) {
      if (jj_2_14(2)) {
        ;
      } else {
        break label_20;
      }
      e2 = DomainRestrictionDecl();
      e3 = N();
                                                                      e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                                        {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp N() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = NN();
    label_21:
    while (true) {
      if (jj_2_15(2)) {
        ;
      } else {
        break label_21;
      }
      e2 = RangeRestrictionDecl();
      e3 = NN();
                                                                       e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                                         {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp NN() throws ParseException {
           Exp e1; Exp e2; Exp e3; Exp e4;
    e1 = O();
    label_22:
    while (true) {
      if (jj_2_16(2)) {
        ;
      } else {
        break label_22;
      }
      e2 = LBracketDecl();
      label_23:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUM:
        case THIS:
        case UNIV:
        case INT:
        case SEQINT:
        case LBRACKET:
        case EQSIGN:
        case INCLUSION:
        case LESSER:
        case GREATER:
        case LESSEROREQUAL:
        case GREATEROREQUAL:
        case SOME:
        case ONE:
        case LONE:
        case SET:
        case OR:
        case AND:
        case DOUBLEIMPLIES:
        case IFF:
        case IMPLIES:
        case PLUS:
        case MINUS:
        case PLUSPLUS:
        case DOMAINRESTRICTION:
        case RANGERESTRICTION:
        case DOT:
        case LEFTSHIFT:
        case RIGHTSHIFT:
        case UNSIGNEDRIGHTSHIFT:
        case BANG:
        case NOT:
        case NO:
        case SEQ:
        case POUND:
        case TILDE:
        case REFLEXIVETRASITIVECLOSURE:
        case NONREFLEXIVETRASITIVECLOSURE:
        case ALL:
        case SUM:
        case LCURLY:
        case LET:
        case IDEN:
        case LPAREN:
        case AT:
        case NONE:
        case ID:
          ;
          break;
        default:
          jj_la1[34] = jj_gen;
          break label_23;
        }
        e3 = O();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          break;
        default:
          jj_la1[35] = jj_gen;
          ;
        }
                                                                    e1 = new UnaryExp(e1, e3);
      }
      e4 = RBracketDecl();
    }
                                                                                                                         {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp O() throws ParseException {
          Exp e1; Exp e2; Exp e3;
    e1 = P();
    label_24:
    while (true) {
      if (jj_2_17(2)) {
        ;
      } else {
        break label_24;
      }
      e2 = DotDecl();
      e3 = P();
                                                        e1 = new BinaryExp(e2,e1,e3);
    }
                                                                                          {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

/** expr ::= "let" letDecl,+ blockOrBar
       | quant decl,+    blockOrBar
       | unOp expr
       | expr binOp   expr
       | expr arrowOp expr
       | expr ["!"|"not"] compareOp expr
       | expr ("=>"|"implies") expr "else" expr
       | expr "[" expr,* "]"
       |     number
       | "-" number
       | "none"
       | "iden"
       | "univ"
       | "Int"
       | "seq/Int"
       | "(" expr ")"
       | ["@"] name
       | block
       | "{" decl,+ blockOrBar "}"
*/
  static final public Exp P() throws ParseException {
          Exp e1; Exp e2; Exp e3; Exp e4;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUM:
      e1 = NumberDecl();
                           {if (true) return e1;}
      break;
    case NONE:
      e1 = NoneDecl();
                         {if (true) return e1;}
      break;
    case IDEN:
      e1 = IdenDecl();
                         {if (true) return e1;}
      break;
    case UNIV:
      e1 = UnivSymDecl();
                            {if (true) return e1;}
      break;
    case INT:
      e1 = IntSymDecl();
                           {if (true) return e1;}
      break;
    case SEQINT:
      e1 = SeqIntSymDecl();
                              {if (true) return e1;}
      break;
    case LPAREN:
      jj_consume_token(LPAREN);
      e1 = ExprDeclE();
      jj_consume_token(RPAREN);
                                  {if (true) return e1;}
      break;
    case AT:
      e1 = AtDecl();
      e2 = QualName();
                                       e1 = new UnaryExp(e1, e2);
                                                                    {if (true) return e1;}
      break;
    case LBRACKET:
      jj_consume_token(LBRACKET);
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUM:
        case THIS:
        case UNIV:
        case INT:
        case SEQINT:
        case LBRACKET:
        case EQSIGN:
        case INCLUSION:
        case LESSER:
        case GREATER:
        case LESSEROREQUAL:
        case GREATEROREQUAL:
        case SOME:
        case ONE:
        case LONE:
        case SET:
        case OR:
        case AND:
        case DOUBLEIMPLIES:
        case IFF:
        case IMPLIES:
        case PLUS:
        case MINUS:
        case PLUSPLUS:
        case DOMAINRESTRICTION:
        case RANGERESTRICTION:
        case DOT:
        case LEFTSHIFT:
        case RIGHTSHIFT:
        case UNSIGNEDRIGHTSHIFT:
        case BANG:
        case NOT:
        case NO:
        case SEQ:
        case POUND:
        case TILDE:
        case REFLEXIVETRASITIVECLOSURE:
        case NONREFLEXIVETRASITIVECLOSURE:
        case ALL:
        case SUM:
        case LCURLY:
        case LET:
        case IDEN:
        case LPAREN:
        case AT:
        case NONE:
        case ID:
          ;
          break;
        default:
          jj_la1[36] = jj_gen;
          break label_25;
        }
        e1 = ExprDeclE();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          break;
        default:
          jj_la1[37] = jj_gen;
          ;
        }
      }
      jj_consume_token(RBRACKET);
      break;
    case NOT:
      e1 = NotDecl();
      e2 = UnaryOrCompExpr();
                                           e1 = new UnaryExp(e1, e2);
                                                                        {if (true) return e1;}
      break;
    case EQSIGN:
    case INCLUSION:
    case LESSER:
    case GREATER:
    case LESSEROREQUAL:
    case GREATEROREQUAL:
      e1 = CompExpr();
                     {if (true) return e1;}
      break;
    default:
      jj_la1[44] = jj_gen;
      if (jj_2_24(5)) {
        e1 = ImpliesDeclExpr();
                                         {if (true) return e1;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
        case AND:
        case DOUBLEIMPLIES:
        case IFF:
        case PLUS:
        case MINUS:
        case PLUSPLUS:
        case DOMAINRESTRICTION:
        case RANGERESTRICTION:
        case DOT:
        case LEFTSHIFT:
        case RIGHTSHIFT:
        case UNSIGNEDRIGHTSHIFT:
          e1 = BinOpExprDecl();
                          {if (true) return e1;}
          break;
        default:
          jj_la1[45] = jj_gen;
          if (jj_2_25(5)) {
            e1 = UnOpExprDecl();
                                          {if (true) return e1;}
          } else if (jj_2_26(5)) {
            e1 = NoDecl();
            e2 = ExprDeclE();
                                                 e1 = new UnaryExp(e1, e2);
                                                                              {if (true) return e1;}
          } else if (jj_2_27(5)) {
            e1 = SomeSymDecl();
            e2 = ExprDeclE();
                                                          e1 = new UnaryExp(e1, e2);
                                                                                       {if (true) return e1;}
          } else if (jj_2_28(5)) {
            e1 = LoneSymDecl();
            e2 = ExprDeclE();
                                                          e1 = new UnaryExp(e1, e2);
                                                                                       {if (true) return e1;}
          } else if (jj_2_29(5)) {
            e1 = OneSymDecl();
            e2 = ExprDeclE();
                                                         e1 = new UnaryExp(e1, e2);
                                                                                      {if (true) return e1;}
          } else if (jj_2_30(5)) {
            e1 = QuantDecl();
            e2 = DeclDecl();
                                                      e1 = new UnaryExp(e1, e2);
            label_26:
            while (true) {
              if (jj_2_18(2)) {
                ;
              } else {
                break label_26;
              }
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                jj_consume_token(COMMA);
                break;
              default:
                jj_la1[38] = jj_gen;
                ;
              }
              e3 = DeclDecl();
                                                                                                                       e1 = new UnaryExp(e1, e3);
            }
            e4 = BlockOrBarDecl();
                                                                                                                                                                            e1 = new UnaryExp(e1, e4);
                                                                                                                                                                                                        {if (true) return e1;}
          } else if (jj_2_31(5)) {
            e1 = NoDecl();
            e2 = DeclDecl();
                                                    e1 = new UnaryExp(e1, e2);
            label_27:
            while (true) {
              if (jj_2_19(2)) {
                ;
              } else {
                break label_27;
              }
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                jj_consume_token(COMMA);
                break;
              default:
                jj_la1[39] = jj_gen;
                ;
              }
              e3 = DeclDecl();
                                                                                                                     e1 = new UnaryExp(e1, e3);
            }
            e4 = BlockOrBarDecl();
                                                                                                                                                                          e1 = new UnaryExp(e1, e4);
                                                                                                                                                                                                       {if (true) return e1;}
          } else if (jj_2_32(5)) {
            e1 = SomeSymDecl();
            e2 = DeclDecl();
                                                         e1 = new UnaryExp(e1, e2);
            label_28:
            while (true) {
              if (jj_2_20(2)) {
                ;
              } else {
                break label_28;
              }
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                jj_consume_token(COMMA);
                break;
              default:
                jj_la1[40] = jj_gen;
                ;
              }
              e3 = DeclDecl();
                                                                                                                          e1 = new UnaryExp(e1, e3);
            }
            e4 = BlockOrBarDecl();
                                                                                                                                                                               e1 = new UnaryExp(e1, e4);
                                                                                                                                                                                                            {if (true) return e1;}
          } else if (jj_2_33(5)) {
            e1 = LoneSymDecl();
            e2 = DeclDecl();
                                                         e1 = new UnaryExp(e1, e2);
            label_29:
            while (true) {
              if (jj_2_21(2)) {
                ;
              } else {
                break label_29;
              }
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                jj_consume_token(COMMA);
                break;
              default:
                jj_la1[41] = jj_gen;
                ;
              }
              e3 = DeclDecl();
                                                                                                                          e1 = new UnaryExp(e1, e3);
            }
            e4 = BlockOrBarDecl();
                                                                                                                                                                               e1 = new UnaryExp(e1, e4);
                                                                                                                                                                                                            {if (true) return e1;}
          } else if (jj_2_34(5)) {
            e1 = OneSymDecl();
            e2 = DeclDecl();
                                                        e1 = new UnaryExp(e1, e2);
            label_30:
            while (true) {
              if (jj_2_22(2)) {
                ;
              } else {
                break label_30;
              }
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                jj_consume_token(COMMA);
                break;
              default:
                jj_la1[42] = jj_gen;
                ;
              }
              e3 = DeclDecl();
                                                                                                                         e1 = new UnaryExp(e1, e3);
            }
            e4 = BlockOrBarDecl();
                                                                                                                                                                              e1 = new UnaryExp(e1, e4);
                                                                                                                                                                                                           {if (true) return e1;}
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case LET:
              jj_consume_token(LET);
              e1 = LetDecl();
              label_31:
              while (true) {
                if (jj_2_23(2)) {
                  ;
                } else {
                  break label_31;
                }
                switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
                case COMMA:
                  jj_consume_token(COMMA);
                  break;
                default:
                  jj_la1[43] = jj_gen;
                  ;
                }
                e2 = LetDecl();
                                                                 e1 = new UnaryExp(e1, e2);
              }
              e3 = BlockOrBarDecl();
                                                                                                                      e1 = new UnaryExp(e1, e3);
                                                                                                                                                  {if (true) return e1;}
              break;
            case LCURLY:
              e1 = LcurlyDecl();
              e2 = PPP();
                                      e1 = new UnaryExp(e1,e2);
                                                                  {if (true) return e1;}
              break;
            case THIS:
            case ID:
              e1 = QualName();
                         {if (true) return e1;}
              break;
            default:
              jj_la1[46] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp PP() throws ParseException {
           Exp e1; Exp e2; Exp e3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BAR:
      jj_consume_token(BAR);
      e1 = ExprDeclE();
                                           {if (true) return e1;}
      break;
    case NUM:
    case THIS:
    case UNIV:
    case INT:
    case SEQINT:
    case LBRACKET:
    case EQSIGN:
    case INCLUSION:
    case LESSER:
    case GREATER:
    case LESSEROREQUAL:
    case GREATEROREQUAL:
    case SOME:
    case ONE:
    case LONE:
    case SET:
    case OR:
    case AND:
    case DOUBLEIMPLIES:
    case IFF:
    case IMPLIES:
    case PLUS:
    case MINUS:
    case PLUSPLUS:
    case DOMAINRESTRICTION:
    case RANGERESTRICTION:
    case DOT:
    case LEFTSHIFT:
    case RIGHTSHIFT:
    case UNSIGNEDRIGHTSHIFT:
    case BANG:
    case NOT:
    case NO:
    case SEQ:
    case POUND:
    case TILDE:
    case REFLEXIVETRASITIVECLOSURE:
    case NONREFLEXIVETRASITIVECLOSURE:
    case ALL:
    case SUM:
    case LCURLY:
    case LET:
    case IDEN:
    case LPAREN:
    case AT:
    case NONE:
    case ID:
      e1 = ExprDeclE();
                                       {if (true) return e1;}
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp PPP() throws ParseException {
            Exp e1; Exp e2; Exp e3;
    if (jj_2_36(2)) {
      e2 = ExprDeclE();
      e3 = RcurlyDecl();
                                                         e1 = new BinaryExp(e3,e2,e3);
                                                                                         {if (true) return e2;}
    } else if (jj_2_37(2)) {
      e1 = DeclDecl();
      label_32:
      while (true) {
        if (jj_2_35(2)) {
          ;
        } else {
          break label_32;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          break;
        default:
          jj_la1[48] = jj_gen;
          ;
        }
        e2 = DeclDecl();
                                                                          e1 = new UnaryExp(e1, e2);
      }
      e3 = BlockOrBarDecl();
                                                                                                                               e1 = new UnaryExp(e1, e3);
      jj_consume_token(RCURLY);
                                                                                                                                                                {if (true) return e1;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp PPPP() throws ParseException {
             Exp e1; Exp e2; Exp e3; Exp e4;
    if (jj_2_38(2)) {
      e2 = ExprDeclE();
                                       {if (true) return e2;}
    } else if (jj_2_39(4)) {
      e2 = DeclDecl();
      e4 = BlockOrBarDecl();
                                                            e2 = new UnaryExp(e2, e4);
                                                                                        {if (true) return e2;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp LetSymDecl() throws ParseException {
                   Token n;
    n = jj_consume_token(LET);
                   {if (true) return new LetSym(n.image);}
    throw new Error("Missing return statement in function");
  }

/**		expr ::= unOp expr
*/
  static final public Exp UnOpExprDecl() throws ParseException {
                     Exp e1; Exp e2; UnaryExp e3;
          e3 = new UnaryExp();
    e1 = UnOpDecl();
    e2 = ExprDeclE();
                                                                  e3.setOp(e1); e3.setExp(e2); {if (true) return e3;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp BinOpExprDecl() throws ParseException {
                      Exp e1; Exp e2; UnaryExp e3;
     e3 = new UnaryExp();
    e1 = BinOpDecl();
    e2 = ExprDeclE();
                                                              e3.setOp(e1); e3.setExp(e2);
                                                                                             {if (true) return e3;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ImpliesDeclExpr() throws ParseException {
                        Exp e1; Exp e2; Exp e3;
    e1 = ImpliesDecl();
    e2 = ExprDeclE();
                                         e1 = new UnaryExp(e1, e2);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
      e3 = ExprDeclE();
                                                                                               e1 = new UnaryExp(e1, e3);
      break;
    default:
      jj_la1[49] = jj_gen;
      ;
    }
                                                                                                                              {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp UnaryOrCompExpr() throws ParseException {
                        Exp e1; Exp e2; UnaryExp e3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQSIGN:
    case INCLUSION:
    case LESSER:
    case GREATER:
    case LESSEROREQUAL:
    case GREATEROREQUAL:
     e3 = new UnaryExp();
      e1 = CompareOpDecl();
      e2 = ExprDeclE();
                                                                  e3.setOp(e1); e3.setExp(e2); {if (true) return e3;}
      break;
    case NUM:
    case THIS:
    case UNIV:
    case INT:
    case SEQINT:
    case LBRACKET:
    case SOME:
    case ONE:
    case LONE:
    case SET:
    case OR:
    case AND:
    case DOUBLEIMPLIES:
    case IFF:
    case IMPLIES:
    case PLUS:
    case MINUS:
    case PLUSPLUS:
    case DOMAINRESTRICTION:
    case RANGERESTRICTION:
    case DOT:
    case LEFTSHIFT:
    case RIGHTSHIFT:
    case UNSIGNEDRIGHTSHIFT:
    case BANG:
    case NOT:
    case NO:
    case SEQ:
    case POUND:
    case TILDE:
    case REFLEXIVETRASITIVECLOSURE:
    case NONREFLEXIVETRASITIVECLOSURE:
    case ALL:
    case SUM:
    case LCURLY:
    case LET:
    case IDEN:
    case LPAREN:
    case AT:
    case NONE:
    case ID:
      e1 = ExprDeclE();
                      {if (true) return e1;}
      break;
    default:
      jj_la1[50] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp CompExpr() throws ParseException {
                 Exp e1; Exp e2; UnaryExp e3;
     e3 = new UnaryExp();
    e1 = CompareOpDecl();
    e2 = ExprDeclE();
                                                                  e3.setOp(e1); e3.setExp(e2); {if (true) return e3;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp NumberDecl() throws ParseException {
                   Token n;
    n = jj_consume_token(NUM);
                   {if (true) return new Id(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp NoneDecl() throws ParseException {
                 Token n;
    n = jj_consume_token(NONE);
                    {if (true) return new None(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp IdenDecl() throws ParseException {
                 Token n;
    n = jj_consume_token(IDEN);
                    {if (true) return new Iden(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp LparenDecl() throws ParseException {
                   Token n;
    n = jj_consume_token(LPAREN);
                      {if (true) return new Lparen(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp RparenDecl() throws ParseException {
                   Token n;
    n = jj_consume_token(RPAREN);
                      {if (true) return new Rparen(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp AtDecl() throws ParseException {
               Token n;
    n = jj_consume_token(AT);
                  {if (true) return new At(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ElseDecl() throws ParseException {
                 Token n;
    n = jj_consume_token(ELSE);
                    {if (true) return new Else(n.image);}
    throw new Error("Missing return statement in function");
  }

/** 	factDecl ::= "fact" [name] block
*/
  static final public Exp FactDecl() throws ParseException {
                 Fact f; Exp e1; Exp e2;
         f = new Fact();
    jj_consume_token(FACT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THIS:
    case ID:
      e1 = QualName();
                                                   f.setName(e1);
      break;
    default:
      jj_la1[51] = jj_gen;
      ;
    }
    jj_consume_token(LCURLY);
    label_33:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUM:
      case THIS:
      case UNIV:
      case INT:
      case SEQINT:
      case LBRACKET:
      case EQSIGN:
      case INCLUSION:
      case LESSER:
      case GREATER:
      case LESSEROREQUAL:
      case GREATEROREQUAL:
      case SOME:
      case ONE:
      case LONE:
      case SET:
      case OR:
      case AND:
      case DOUBLEIMPLIES:
      case IFF:
      case IMPLIES:
      case PLUS:
      case MINUS:
      case PLUSPLUS:
      case DOMAINRESTRICTION:
      case RANGERESTRICTION:
      case DOT:
      case LEFTSHIFT:
      case RIGHTSHIFT:
      case UNSIGNEDRIGHTSHIFT:
      case BANG:
      case NOT:
      case NO:
      case SEQ:
      case POUND:
      case TILDE:
      case REFLEXIVETRASITIVECLOSURE:
      case NONREFLEXIVETRASITIVECLOSURE:
      case ALL:
      case SUM:
      case LCURLY:
      case LET:
      case IDEN:
      case LPAREN:
      case AT:
      case NONE:
      case ID:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_33;
      }
      e2 = ExprDeclE();
                       f.addBlock(e2);
    }
    jj_consume_token(RCURLY);
         {if (true) return f;}
    throw new Error("Missing return statement in function");
  }

/** 	assertDecl ::= "assert" [name] block
*/
  static final public Exp AssertDecl() throws ParseException {
                   Fact f; Exp e1; Exp e2;
         f = new Fact();
    jj_consume_token(ASSERT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THIS:
    case ID:
      e1 = QualName();
                                                     f.setName(e1);
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    jj_consume_token(LCURLY);
    label_34:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUM:
      case THIS:
      case UNIV:
      case INT:
      case SEQINT:
      case LBRACKET:
      case EQSIGN:
      case INCLUSION:
      case LESSER:
      case GREATER:
      case LESSEROREQUAL:
      case GREATEROREQUAL:
      case SOME:
      case ONE:
      case LONE:
      case SET:
      case OR:
      case AND:
      case DOUBLEIMPLIES:
      case IFF:
      case IMPLIES:
      case PLUS:
      case MINUS:
      case PLUSPLUS:
      case DOMAINRESTRICTION:
      case RANGERESTRICTION:
      case DOT:
      case LEFTSHIFT:
      case RIGHTSHIFT:
      case UNSIGNEDRIGHTSHIFT:
      case BANG:
      case NOT:
      case NO:
      case SEQ:
      case POUND:
      case TILDE:
      case REFLEXIVETRASITIVECLOSURE:
      case NONREFLEXIVETRASITIVECLOSURE:
      case ALL:
      case SUM:
      case LCURLY:
      case LET:
      case IDEN:
      case LPAREN:
      case AT:
      case NONE:
      case ID:
        ;
        break;
      default:
        jj_la1[54] = jj_gen;
        break label_34;
      }
      e2 = ExprDeclE();
                       f.addBlock(e2);
    }
    jj_consume_token(RCURLY);
     {if (true) return f;}
    throw new Error("Missing return statement in function");
  }

/** 	funDecl ::= ["private"] "fun" [ref "."] name "(" decl,* ")" ":" expr block
		funDecl ::= ["private"] "fun" [ref "."] name "[" decl,* "]" ":" expr block
		funDecl ::= ["private"] "fun" [ref "."] name                ":" expr block
*/
  static final public Exp FunDecl() throws ParseException {
                Function f; Exp e1; Exp e2; Exp e3; Exp e4; Exp e5; Exp e6; Exp e7; Exp e8;
         f = new Function();
    jj_consume_token(FUNCTION);
    if (jj_2_40(2)) {
      e2 = RefName();
      jj_consume_token(DOT);
                                          f.setRef(e2);
    } else {
      ;
    }
    e3 = QualName();
                                                                            f.setName(e3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      break;
    default:
      jj_la1[55] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      break;
    default:
      jj_la1[56] = jj_gen;
      ;
    }
    label_35:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THIS:
      case PRIVATE:
      case DISJOINT:
      case ID:
        ;
        break;
      default:
        jj_la1[57] = jj_gen;
        break label_35;
      }
      e4 = DeclDecl();
                                       f.addArguments(e4);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RBRACKET:
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[59] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[60] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    e5 = ExprDeclE();
                          f.setExpr(e5);
    e6 = LcurlyDecl();
    label_36:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUM:
      case THIS:
      case UNIV:
      case INT:
      case SEQINT:
      case LBRACKET:
      case EQSIGN:
      case INCLUSION:
      case LESSER:
      case GREATER:
      case LESSEROREQUAL:
      case GREATEROREQUAL:
      case SOME:
      case ONE:
      case LONE:
      case SET:
      case OR:
      case AND:
      case DOUBLEIMPLIES:
      case IFF:
      case IMPLIES:
      case PLUS:
      case MINUS:
      case PLUSPLUS:
      case DOMAINRESTRICTION:
      case RANGERESTRICTION:
      case DOT:
      case LEFTSHIFT:
      case RIGHTSHIFT:
      case UNSIGNEDRIGHTSHIFT:
      case BANG:
      case NOT:
      case NO:
      case SEQ:
      case POUND:
      case TILDE:
      case REFLEXIVETRASITIVECLOSURE:
      case NONREFLEXIVETRASITIVECLOSURE:
      case ALL:
      case SUM:
      case LCURLY:
      case LET:
      case IDEN:
      case LPAREN:
      case AT:
      case NONE:
      case ID:
        ;
        break;
      default:
        jj_la1[61] = jj_gen;
        break label_36;
      }
      e7 = ExprDeclE();
                                             f.addBlock(e7);
                                                               e6 = new UnaryExp(e6,e7);
    }
    e8 = RcurlyDecl();
                                                                                                               e6 = new BinaryExp(e8,e6,e8);
         {if (true) return f;}
    throw new Error("Missing return statement in function");
  }

/** 	predDecl ::= ["private"] "pred" [ref "."] name "(" decl,* ")" block
		predDecl ::= ["private"] "pred" [ref "."] name "[" decl,* "]" block
		predDecl ::= ["private"] "pred" [ref "."] name                block
*/
  static final public Exp PredDecl() throws ParseException {
                 Function f; Exp e1; Exp e2; Exp e3; Exp e4; Exp e5; Exp e6; Exp e7; Exp e8;
         f = new Function(); f.setPredTrue();
    jj_consume_token(PREDICATE);
    if (jj_2_41(2)) {
      e2 = RefName();
      jj_consume_token(DOT);
                                          f.setRef(e2);
    } else {
      ;
    }
    e3 = QualName();
                                                                            f.setName(e3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LPAREN:
      jj_consume_token(LPAREN);
      break;
    default:
      jj_la1[62] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      jj_consume_token(LBRACKET);
      break;
    default:
      jj_la1[63] = jj_gen;
      ;
    }
    label_37:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THIS:
      case PRIVATE:
      case DISJOINT:
      case ID:
        ;
        break;
      default:
        jj_la1[64] = jj_gen;
        break label_37;
      }
      e4 = DeclDecl();
                                       f.addArguments(e4);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[65] = jj_gen;
        ;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RBRACKET:
      jj_consume_token(RBRACKET);
      break;
    default:
      jj_la1[66] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RPAREN:
      jj_consume_token(RPAREN);
      break;
    default:
      jj_la1[67] = jj_gen;
      ;
    }
    e6 = LcurlyDecl();
    label_38:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUM:
      case THIS:
      case UNIV:
      case INT:
      case SEQINT:
      case LBRACKET:
      case EQSIGN:
      case INCLUSION:
      case LESSER:
      case GREATER:
      case LESSEROREQUAL:
      case GREATEROREQUAL:
      case SOME:
      case ONE:
      case LONE:
      case SET:
      case OR:
      case AND:
      case DOUBLEIMPLIES:
      case IFF:
      case IMPLIES:
      case PLUS:
      case MINUS:
      case PLUSPLUS:
      case DOMAINRESTRICTION:
      case RANGERESTRICTION:
      case DOT:
      case LEFTSHIFT:
      case RIGHTSHIFT:
      case UNSIGNEDRIGHTSHIFT:
      case BANG:
      case NOT:
      case NO:
      case SEQ:
      case POUND:
      case TILDE:
      case REFLEXIVETRASITIVECLOSURE:
      case NONREFLEXIVETRASITIVECLOSURE:
      case ALL:
      case SUM:
      case LCURLY:
      case LET:
      case IDEN:
      case LPAREN:
      case AT:
      case NONE:
      case ID:
        ;
        break;
      default:
        jj_la1[68] = jj_gen;
        break label_38;
      }
      e7 = ExprDeclE();
                                             f.addBlock(e7);
                                                               e6 = new UnaryExp(e6,e7);
    }
    e8 = RcurlyDecl();
                                                                                                               e6 = new BinaryExp(e8,e6,e8);
         {if (true) return f;}
    throw new Error("Missing return statement in function");
  }

/** 	cmdDecl ::= [name ":"] ("run"|"check") (name|block) scope
*/
  static final public Exp CommandDecl() throws ParseException {
                    Command c; Exp e1; Exp e2; Exp e3; Exp e4; Exp e5;
         c = new Command();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THIS:
    case ID:
      e1 = QualName();
                                               c.setName(e1);
      jj_consume_token(COLON);
      break;
    default:
      jj_la1[69] = jj_gen;
      ;
    }
    e2 = RunCheckDecl();
                                                                                          c.setType(e2);
    e3 = NameBlock();
                          c.setQualName(e3);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FOR:
      e4 = ScopeDecl();
                                                                 c.setScope(e4);
      break;
    default:
      jj_la1[70] = jj_gen;
      ;
    }
                                                                                     {if (true) return c;}
    throw new Error("Missing return statement in function");
  }

/** 	RunCheckDecl ::= ("run"|"check")
*/
  static final public Exp RunCheckDecl() throws ParseException {
                     Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RUN:
      n = jj_consume_token(RUN);
                   {if (true) return new Run(n.image);}
      break;
    case CHECK:
      n = jj_consume_token(CHECK);
                     {if (true) return new Check(n.image);}
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**		NameBlock ::= (name|block)
*/
  static final public Exp NameBlock() throws ParseException {
                  Exp e1; Exp e2; Exp e3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THIS:
    case ID:
      e1 = QualName();
                         {if (true) return e1;}
      break;
    case LCURLY:
      e1 = LcurlyDecl();
      label_39:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUM:
        case THIS:
        case UNIV:
        case INT:
        case SEQINT:
        case LBRACKET:
        case EQSIGN:
        case INCLUSION:
        case LESSER:
        case GREATER:
        case LESSEROREQUAL:
        case GREATEROREQUAL:
        case SOME:
        case ONE:
        case LONE:
        case SET:
        case OR:
        case AND:
        case DOUBLEIMPLIES:
        case IFF:
        case IMPLIES:
        case PLUS:
        case MINUS:
        case PLUSPLUS:
        case DOMAINRESTRICTION:
        case RANGERESTRICTION:
        case DOT:
        case LEFTSHIFT:
        case RIGHTSHIFT:
        case UNSIGNEDRIGHTSHIFT:
        case BANG:
        case NOT:
        case NO:
        case SEQ:
        case POUND:
        case TILDE:
        case REFLEXIVETRASITIVECLOSURE:
        case NONREFLEXIVETRASITIVECLOSURE:
        case ALL:
        case SUM:
        case LCURLY:
        case LET:
        case IDEN:
        case LPAREN:
        case AT:
        case NONE:
        case ID:
          ;
          break;
        default:
          jj_la1[72] = jj_gen;
          break label_39;
        }
        e2 = ExprDeclE();
                                             e1 = new UnaryExp(e1,e2);
      }
      e3 = RcurlyDecl();
                                                                                             e1 = new BinaryExp(e3,e1,e3);
      break;
    default:
      jj_la1[73] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/**		scope ::= "for" number                   ["expect" (0|1)]
		scope ::= "for" number "but" typescope,+ ["expect" (0|1)]
		scope ::= "for"              typescope,+ ["expect" (0|1)]
		scope ::=                                ["expect" (0|1)]
*/
  static final public Exp ScopeDecl() throws ParseException {
                  Exp e1; Exp e2;
    e1 = ForDecl();
    e2 = ScopeDeclPrime();
                                              e1 = new BinaryExp(e2, e1, e2);
                                                                                {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ScopeDeclPrime() throws ParseException {
                       Exp e1; Exp e2; Exp e3; Exp e4;
    if (jj_2_42(2)) {
      e1 = NumberDecl();
      e2 = ButDecl();
                                                   e1 = new BinaryExp(e2,e1,e2);
      label_40:
      while (true) {
        e3 = TypescopeDecl();
                               e1 = new BinaryExp(e3,e1,e3);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUM:
        case EXACTLY:
          ;
          break;
        default:
          jj_la1[74] = jj_gen;
          break label_40;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPECT:
        e4 = ExpectDecl();
                            e1 = new BinaryExp(e4,e1,e4);
        break;
      default:
        jj_la1[75] = jj_gen;
        ;
      }
         {if (true) return e1;}
    } else if (jj_2_43(2)) {
      label_41:
      while (true) {
        e1 = TypescopeDecl();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUM:
        case EXACTLY:
          ;
          break;
        default:
          jj_la1[76] = jj_gen;
          break label_41;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXPECT:
        e2 = ExpectDecl();
                            e1 = new BinaryExp(e2,e1,e2);
        break;
      default:
        jj_la1[77] = jj_gen;
        ;
      }
         {if (true) return e1;}
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/** 	typescope ::= ["exactly"] number [name|"int"|"seq"]
*/
  static final public Exp TypescopeDecl() throws ParseException {
                      Exp e1; Exp e2; Exp e3;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXACTLY:
      e1 = ExactlyDecl();
      break;
    default:
      jj_la1[78] = jj_gen;
      ;
    }
    e2 = NumberDecl();
    if (jj_2_44(2)) {
      e3 = TypescopeDecl1();
                                                                                     e2 = new BinaryExp(e3,e2,e3);
    } else {
      ;
    }
                                                                                                                       {if (true) return e2;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp TypescopeDecl1() throws ParseException {
                       Exp e1;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THIS:
    case ID:
      e1 = QualName();
                         {if (true) return e1;}
      break;
    case INT:
      e1 = IntSymDecl();
                           {if (true) return e1;}
      break;
    case SEQ:
      e1 = SeqDecl();
                        {if (true) return e1;}
      break;
    default:
      jj_la1[79] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp ForDecl() throws ParseException {
                Token n;
    n = jj_consume_token(FOR);
                  {if (true) return new For(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ButDecl() throws ParseException {
                Token n;
    n = jj_consume_token(BUT);
                  {if (true) return new But(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ExpectDecl() throws ParseException {
                   Exp e1; Exp e2;
    e1 = ExpectSymDecl();
    e2 = ZeroOneDecl();
                                                 e1 = new BinaryExp(e1,e1,e2); {if (true) return e1;}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ExpectSymDecl() throws ParseException {
                      Token n;
    n = jj_consume_token(EXPECT);
                      {if (true) return new Expect(n.image);}
    throw new Error("Missing return statement in function");
  }

  static final public Exp ZeroOneDecl() throws ParseException {
                    Token n;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ZERO:
      n = jj_consume_token(ZERO);
                    {if (true) return new Zero(n.image);}
      break;
    case ONEDIGIT:
      n = jj_consume_token(ONEDIGIT);
                        {if (true) return new OneDigit(n.image);}
      break;
    default:
      jj_la1[80] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

/* 		enumDecl ::= "enum" name "{" name  ("," name)*  "}"
*/
  static final public Exp EnumDecl() throws ParseException {
                 Enum e; Exp e1; Exp e2; Exp e3;
         e = new Enum();
    jj_consume_token(ENUM);
    e1 = QualName();
                                                  e.setName(e1);
    jj_consume_token(LCURLY);
    e2 = QualName();
                                                                                       e.addBody(e2);
    label_42:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[81] = jj_gen;
        break label_42;
      }
      jj_consume_token(COMMA);
      e3 = QualName();
                              e.addBody(e3);
    }
    jj_consume_token(RCURLY);
                                                     {if (true) return e;}
    throw new Error("Missing return statement in function");
  }

/** 	sigDecl ::= sigQual* "sig" name,+ [sigExt] 
		"{" decl,* "}" [block] 
*/
  static final public Exp SignatureDecl() throws ParseException {
                      Signature s; Exp e1; Exp e2; Exp e3;
 Exp e4; Exp e5; Exp e6; Exp e7; Exp e8;
          s = new Signature();
    label_43:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SOME:
      case ONE:
      case LONE:
      case ABSTRACT:
        ;
        break;
      default:
        jj_la1[82] = jj_gen;
        break label_43;
      }
      e1 = SigQualDecl();
                               s.addQualifier(e1);
    }
    jj_consume_token(SIGNATURE);
    e2 = QualName();
    label_44:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THIS:
      case COMMA:
      case ID:
        ;
        break;
      default:
        jj_la1[83] = jj_gen;
        break label_44;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[84] = jj_gen;
        ;
      }
      e3 = QualName();
                                   e2 = new UnaryExp(e2,e3);
    }
         s.setName(e2);
    label_45:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INCLUSION:
      case EXTENDS:
        ;
        break;
      default:
        jj_la1[85] = jj_gen;
        break label_45;
      }
      e4 = SigExtDecl(s);
    }
    jj_consume_token(LCURLY);
    label_46:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THIS:
      case PRIVATE:
      case DISJOINT:
      case ID:
        ;
        break;
      default:
        jj_la1[86] = jj_gen;
        break label_46;
      }
      e5 = DeclDecl();
                               s.addBody(e5);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[87] = jj_gen;
        ;
      }
    }
    jj_consume_token(RCURLY);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LCURLY:
      e6 = LcurlyDecl();
      label_47:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NUM:
        case THIS:
        case UNIV:
        case INT:
        case SEQINT:
        case LBRACKET:
        case EQSIGN:
        case INCLUSION:
        case LESSER:
        case GREATER:
        case LESSEROREQUAL:
        case GREATEROREQUAL:
        case SOME:
        case ONE:
        case LONE:
        case SET:
        case OR:
        case AND:
        case DOUBLEIMPLIES:
        case IFF:
        case IMPLIES:
        case PLUS:
        case MINUS:
        case PLUSPLUS:
        case DOMAINRESTRICTION:
        case RANGERESTRICTION:
        case DOT:
        case LEFTSHIFT:
        case RIGHTSHIFT:
        case UNSIGNEDRIGHTSHIFT:
        case BANG:
        case NOT:
        case NO:
        case SEQ:
        case POUND:
        case TILDE:
        case REFLEXIVETRASITIVECLOSURE:
        case NONREFLEXIVETRASITIVECLOSURE:
        case ALL:
        case SUM:
        case LCURLY:
        case LET:
        case IDEN:
        case LPAREN:
        case AT:
        case NONE:
        case ID:
          ;
          break;
        default:
          jj_la1[88] = jj_gen;
          break label_47;
        }
        e7 = ExprDeclE();
         e6 = new UnaryExp(e6,e7);
                                     s.addBlock(e7);
      }
      e8 = RcurlyDecl();
                           e6 = new BinaryExp(e8,e6,e8);
      break;
    default:
      jj_la1[89] = jj_gen;
      ;
    }
         {if (true) return s;}
    throw new Error("Missing return statement in function");
  }

/** 	sigQual ::= "abstract" | "lone" | "one" | "some" | "private" 
*/
  static final public Exp SigQualDecl() throws ParseException {
                    Exp e;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ABSTRACT:
      e = AbstractSymDecl();
                               {if (true) return e;}
      break;
    case LONE:
      e = LoneSymDecl();
                           {if (true) return e;}
      break;
    case ONE:
      e = OneSymDecl();
                          {if (true) return e;}
      break;
    case SOME:
      e = SomeSymDecl();
                           {if (true) return e;}
      break;
    default:
      jj_la1[90] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public Exp AbstractSymDecl() throws ParseException {
                        Token n;
    n = jj_consume_token(ABSTRACT);
                        {if (true) return new Abstract(n.image);}
    throw new Error("Missing return statement in function");
  }

/** 	sigExt ::= "extends" ref
		sigExt ::= "in" ref ["+" ref]* 
*/
  static final public Exp SigExtDecl(Signature s) throws ParseException {
                              Exp e1; Exp e2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      jj_consume_token(EXTENDS);
      e1 = RefName();
                                  s.extension = true;
                                                        s.setParentClass(e1);
                                                                                {if (true) return e1;}
      break;
    case INCLUSION:
      jj_consume_token(INCLUSION);
      e1 = RefName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THIS:
      case UNIV:
      case INT:
      case SEQINT:
      case PLUS:
      case ID:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PLUS:
          jj_consume_token(PLUS);
          break;
        default:
          jj_la1[91] = jj_gen;
          ;
        }
        label_48:
        while (true) {
          e2 = RefName();
                                                     e1 = new UnaryExp(e1,e2);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case THIS:
          case UNIV:
          case INT:
          case SEQINT:
          case ID:
            ;
            break;
          default:
            jj_la1[92] = jj_gen;
            break label_48;
          }
        }
        break;
      default:
        jj_la1[93] = jj_gen;
        ;
      }
         s.composition = true;
                                 s.setWholeClass(e1);
                                                       {if (true) return e1;}
      break;
    default:
      jj_la1[94] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  static private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  static private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  static private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  static private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  static private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  static private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  static private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  static private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  static private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  static private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  static private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  static private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  static private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  static private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  static private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  static private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  static private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  static private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  static private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  static private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  static private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  static private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  static private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  static private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  static private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  static private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  static private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  static private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  static private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  static private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  static private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  static private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  static private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  static private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  static private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  static private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  static private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  static private boolean jj_3R_56() {
    if (jj_scan_token(AND)) return true;
    return false;
  }

  static private boolean jj_3R_234() {
    if (jj_3R_169()) return true;
    return false;
  }

  static private boolean jj_3R_233() {
    if (jj_3R_168()) return true;
    return false;
  }

  static private boolean jj_3R_232() {
    if (jj_3R_167()) return true;
    return false;
  }

  static private boolean jj_3R_231() {
    if (jj_3R_80()) return true;
    return false;
  }

  static private boolean jj_3R_230() {
    if (jj_3R_75()) return true;
    return false;
  }

  static private boolean jj_3_17() {
    if (jj_3R_80()) return true;
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_229() {
    if (jj_3R_73()) return true;
    return false;
  }

  static private boolean jj_3R_228() {
    if (jj_3R_68()) return true;
    return false;
  }

  static private boolean jj_3_16() {
    if (jj_3R_77()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_78()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_79()) return true;
    return false;
  }

  static private boolean jj_3R_227() {
    if (jj_3R_171()) return true;
    return false;
  }

  static private boolean jj_3R_226() {
    if (jj_3R_170()) return true;
    return false;
  }

  static private boolean jj_3_15() {
    if (jj_3R_75()) return true;
    if (jj_3R_76()) return true;
    return false;
  }

  static private boolean jj_3R_225() {
    if (jj_3R_236()) return true;
    return false;
  }

  static private boolean jj_3R_120() {
    if (jj_3R_81()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_17()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_224() {
    if (jj_3R_52()) return true;
    return false;
  }

  static private boolean jj_3R_223() {
    if (jj_3R_50()) return true;
    return false;
  }

  static private boolean jj_3_14() {
    if (jj_3R_73()) return true;
    if (jj_3R_74()) return true;
    return false;
  }

  static private boolean jj_3R_76() {
    if (jj_3R_120()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_16()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_222() {
    if (jj_3R_56()) return true;
    return false;
  }

  static private boolean jj_3R_207() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_222()) {
    jj_scanpos = xsp;
    if (jj_3R_223()) {
    jj_scanpos = xsp;
    if (jj_3R_224()) {
    jj_scanpos = xsp;
    if (jj_3R_225()) {
    jj_scanpos = xsp;
    if (jj_3R_226()) {
    jj_scanpos = xsp;
    if (jj_3R_227()) {
    jj_scanpos = xsp;
    if (jj_3R_228()) {
    jj_scanpos = xsp;
    if (jj_3R_229()) {
    jj_scanpos = xsp;
    if (jj_3R_230()) {
    jj_scanpos = xsp;
    if (jj_3R_231()) {
    jj_scanpos = xsp;
    if (jj_3R_232()) {
    jj_scanpos = xsp;
    if (jj_3R_233()) {
    jj_scanpos = xsp;
    if (jj_3R_234()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_74() {
    if (jj_3R_76()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_15()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_13() {
    if (jj_3R_71()) return true;
    if (jj_3R_72()) return true;
    return false;
  }

  static private boolean jj_3R_159() {
    if (jj_scan_token(SET)) return true;
    return false;
  }

  static private boolean jj_3R_72() {
    if (jj_3R_74()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_14()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_12() {
    if (jj_3R_56()) return true;
    if (jj_3R_70()) return true;
    return false;
  }

  static private boolean jj_3R_89() {
    if (jj_scan_token(LONE)) return true;
    return false;
  }

  static private boolean jj_3R_70() {
    if (jj_3R_72()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_13()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_11() {
    if (jj_3R_68()) return true;
    if (jj_3R_69()) return true;
    return false;
  }

  static private boolean jj_3R_90() {
    if (jj_scan_token(ONE)) return true;
    return false;
  }

  static private boolean jj_3R_69() {
    if (jj_3R_70()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_12()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_10() {
    if (jj_3R_66()) return true;
    if (jj_3R_67()) return true;
    return false;
  }

  static private boolean jj_3R_88() {
    if (jj_scan_token(SOME)) return true;
    return false;
  }

  static private boolean jj_3R_67() {
    if (jj_3R_69()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_11()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_103() {
    if (jj_3R_159()) return true;
    return false;
  }

  static private boolean jj_3R_65() {
    if (jj_3R_67()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_10()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_102() {
    if (jj_3R_89()) return true;
    return false;
  }

  static private boolean jj_3_9() {
    if (jj_3R_64()) return true;
    if (jj_3R_65()) return true;
    return false;
  }

  static private boolean jj_3R_101() {
    if (jj_3R_90()) return true;
    return false;
  }

  static private boolean jj_3R_117() {
    if (jj_3R_171()) return true;
    return false;
  }

  static private boolean jj_3R_49() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_100() {
    if (jj_3R_88()) return true;
    return false;
  }

  static private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) return true;
    }
    return false;
  }

  static private boolean jj_3R_116() {
    if (jj_3R_170()) return true;
    return false;
  }

  static private boolean jj_3R_119() {
    if (jj_scan_token(ARROW)) return true;
    return false;
  }

  static private boolean jj_3R_63() {
    if (jj_3R_65()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_9()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_49()) return true;
    return false;
  }

  static private boolean jj_3_8() {
    if (jj_3R_62()) return true;
    if (jj_3R_63()) return true;
    return false;
  }

  static private boolean jj_3R_118() {
    if (jj_3R_49()) return true;
    return false;
  }

  static private boolean jj_3R_115() {
    if (jj_3R_169()) return true;
    return false;
  }

  static private boolean jj_3R_71() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_118()) jj_scanpos = xsp;
    if (jj_3R_119()) return true;
    xsp = jj_scanpos;
    if (jj_3_1()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_114() {
    if (jj_3R_168()) return true;
    return false;
  }

  static private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_113()) {
    jj_scanpos = xsp;
    if (jj_3R_114()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_113() {
    if (jj_3R_167()) return true;
    return false;
  }

  static private boolean jj_3R_61() {
    if (jj_3R_63()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_8()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_165() {
    if (jj_scan_token(GREATEROREQUAL)) return true;
    return false;
  }

  static private boolean jj_3_44() {
    if (jj_3R_99()) return true;
    return false;
  }

  static private boolean jj_3R_205() {
    if (jj_3R_165()) return true;
    return false;
  }

  static private boolean jj_3R_164() {
    if (jj_scan_token(LESSEROREQUAL)) return true;
    return false;
  }

  static private boolean jj_3R_204() {
    if (jj_3R_164()) return true;
    return false;
  }

  static private boolean jj_3R_203() {
    if (jj_3R_163()) return true;
    return false;
  }

  static private boolean jj_3R_202() {
    if (jj_3R_162()) return true;
    return false;
  }

  static private boolean jj_3R_163() {
    if (jj_scan_token(GREATER)) return true;
    return false;
  }

  static private boolean jj_3R_147() {
    if (jj_3R_183()) return true;
    return false;
  }

  static private boolean jj_3R_201() {
    if (jj_3R_141()) return true;
    return false;
  }

  static private boolean jj_3R_198() {
    if (jj_scan_token(EXPECT)) return true;
    return false;
  }

  static private boolean jj_3R_200() {
    if (jj_3R_161()) return true;
    return false;
  }

  static private boolean jj_3R_166() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_200()) {
    jj_scanpos = xsp;
    if (jj_3R_201()) {
    jj_scanpos = xsp;
    if (jj_3R_202()) {
    jj_scanpos = xsp;
    if (jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_162() {
    if (jj_scan_token(LESSER)) return true;
    return false;
  }

  static private boolean jj_3R_155() {
    if (jj_3R_198()) return true;
    return false;
  }

  static private boolean jj_3R_112() {
    if (jj_3R_58()) return true;
    if (jj_3R_166()) return true;
    return false;
  }

  static private boolean jj_3R_161() {
    if (jj_scan_token(INCLUSION)) return true;
    return false;
  }

  static private boolean jj_3R_111() {
    if (jj_3R_165()) return true;
    return false;
  }

  static private boolean jj_3R_96() {
    if (jj_scan_token(BUT)) return true;
    return false;
  }

  static private boolean jj_3R_110() {
    if (jj_3R_164()) return true;
    return false;
  }

  static private boolean jj_3R_141() {
    if (jj_scan_token(EQSIGN)) return true;
    return false;
  }

  static private boolean jj_3R_109() {
    if (jj_3R_163()) return true;
    return false;
  }

  static private boolean jj_3_7() {
    if (jj_3R_60()) return true;
    if (jj_3R_61()) return true;
    return false;
  }

  static private boolean jj_3R_108() {
    if (jj_3R_162()) return true;
    return false;
  }

  static private boolean jj_3R_107() {
    if (jj_3R_141()) return true;
    return false;
  }

  static private boolean jj_3R_221() {
    if (jj_3R_165()) return true;
    return false;
  }

  static private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) {
    jj_scanpos = xsp;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_6() {
    if (jj_3R_58()) return true;
    if (jj_3R_59()) return true;
    return false;
  }

  static private boolean jj_3R_106() {
    if (jj_3R_161()) return true;
    return false;
  }

  static private boolean jj_3R_220() {
    if (jj_3R_164()) return true;
    return false;
  }

  static private boolean jj_3R_158() {
    if (jj_3R_199()) return true;
    return false;
  }

  static private boolean jj_3R_219() {
    if (jj_3R_163()) return true;
    return false;
  }

  static private boolean jj_3R_157() {
    if (jj_3R_175()) return true;
    return false;
  }

  static private boolean jj_3R_218() {
    if (jj_3R_162()) return true;
    return false;
  }

  static private boolean jj_3R_156() {
    if (jj_3R_138()) return true;
    return false;
  }

  static private boolean jj_3R_59() {
    if (jj_3R_61()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_7()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_3R_56()) return true;
    if (jj_3R_57()) return true;
    return false;
  }

  static private boolean jj_3R_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) return true;
    }
    }
    return false;
  }

  static private boolean jj_3R_217() {
    if (jj_3R_161()) return true;
    return false;
  }

  static private boolean jj_3R_216() {
    if (jj_3R_141()) return true;
    return false;
  }

  static private boolean jj_3R_206() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_197() {
    if (jj_3R_215()) return true;
    return false;
  }

  static private boolean jj_3R_154() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_197()) jj_scanpos = xsp;
    if (jj_3R_95()) return true;
    xsp = jj_scanpos;
    if (jj_3_44()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_57() {
    if (jj_3R_59()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_6()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_97() {
    if (jj_3R_154()) return true;
    return false;
  }

  static private boolean jj_3R_55() {
    if (jj_3R_57()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_5()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_182() {
    if (jj_scan_token(PRIVATE)) return true;
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_54()) return true;
    if (jj_3R_55()) return true;
    return false;
  }

  static private boolean jj_3R_98() {
    if (jj_3R_155()) return true;
    return false;
  }

  static private boolean jj_3R_105() {
    if (jj_3R_160()) return true;
    return false;
  }

  static private boolean jj_3R_54() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) return true;
    }
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_52()) return true;
    if (jj_3R_53()) return true;
    return false;
  }

  static private boolean jj_3R_104() {
    if (jj_3R_142()) return true;
    return false;
  }

  static private boolean jj_3_43() {
    Token xsp;
    if (jj_3R_97()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_97()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_98()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_53() {
    if (jj_3R_55()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_4()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_50()) return true;
    if (jj_3R_51()) return true;
    return false;
  }

  static private boolean jj_3_42() {
    if (jj_3R_95()) return true;
    if (jj_3R_96()) return true;
    return false;
  }

  static private boolean jj_3R_176() {
    if (jj_scan_token(SEQINT)) return true;
    return false;
  }

  static private boolean jj_3R_51() {
    if (jj_3R_53()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_3()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_175() {
    if (jj_scan_token(INT)) return true;
    return false;
  }

  static private boolean jj_3R_87() {
    if (jj_3R_51()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_2()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_174() {
    if (jj_scan_token(UNIV)) return true;
    return false;
  }

  static private boolean jj_3R_137() {
    if (jj_3R_183()) return true;
    return false;
  }

  static private boolean jj_3R_153() {
    if (jj_3R_176()) return true;
    return false;
  }

  static private boolean jj_3R_152() {
    if (jj_3R_175()) return true;
    return false;
  }

  static private boolean jj_3R_151() {
    if (jj_3R_174()) return true;
    return false;
  }

  static private boolean jj_3R_150() {
    if (jj_3R_138()) return true;
    return false;
  }

  static private boolean jj_3R_94() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) return true;
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_93() {
    if (jj_scan_token(RCURLY)) return true;
    return false;
  }

  static private boolean jj_3R_181() {
    if (jj_scan_token(LCURLY)) return true;
    return false;
  }

  static private boolean jj_3_41() {
    if (jj_3R_94()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  static private boolean jj_3R_196() {
    if (jj_scan_token(LCURLY)) return true;
    return false;
  }

  static private boolean jj_3R_195() {
    if (jj_scan_token(BAR)) return true;
    return false;
  }

  static private boolean jj_3R_139() {
    if (jj_3R_138()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_40() {
    if (jj_3R_94()) return true;
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  static private boolean jj_3R_215() {
    if (jj_scan_token(EXACTLY)) return true;
    return false;
  }

  static private boolean jj_3R_136() {
    if (jj_3R_182()) return true;
    return false;
  }

  static private boolean jj_3R_148() {
    if (jj_3R_195()) return true;
    return false;
  }

  static private boolean jj_3R_92() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) return true;
    }
    return false;
  }

  static private boolean jj_3R_149() {
    if (jj_3R_196()) return true;
    return false;
  }

  static private boolean jj_3R_79() {
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_183() {
    if (jj_scan_token(DISJOINT)) return true;
    return false;
  }

  static private boolean jj_3R_77() {
    if (jj_scan_token(LBRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_140() {
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  static private boolean jj_3R_211() {
    if (jj_3R_235()) return true;
    if (jj_3R_210()) return true;
    return false;
  }

  static private boolean jj_3R_143() {
    if (jj_scan_token(ELSE)) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_82() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_136()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_137()) jj_scanpos = xsp;
    if (jj_3R_138()) return true;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_139()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_140()) return true;
    xsp = jj_scanpos;
    if (jj_3R_147()) jj_scanpos = xsp;
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_209() {
    if (jj_3R_235()) return true;
    if (jj_3R_210()) return true;
    return false;
  }

  static private boolean jj_3R_208() {
    if (jj_scan_token(THIS)) return true;
    return false;
  }

  static private boolean jj_3R_83() {
    if (jj_3R_138()) return true;
    if (jj_3R_141()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_210() {
    if (jj_scan_token(ID)) return true;
    return false;
  }

  static private boolean jj_3R_160() {
    if (jj_scan_token(ELSE)) return true;
    return false;
  }

  static private boolean jj_3R_235() {
    if (jj_scan_token(STROKE)) return true;
    return false;
  }

  static private boolean jj_3R_194() {
    if (jj_scan_token(SUM)) return true;
    return false;
  }

  static private boolean jj_3R_177() {
    if (jj_scan_token(AT)) return true;
    return false;
  }

  static private boolean jj_3R_185() {
    if (jj_3R_210()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_211()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_193() {
    if (jj_scan_token(ALL)) return true;
    return false;
  }

  static private boolean jj_3R_184() {
    if (jj_3R_208()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_209()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_138() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) return true;
    }
    return false;
  }

  static private boolean jj_3R_146() {
    if (jj_3R_194()) return true;
    return false;
  }

  static private boolean jj_3R_91() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) return true;
    }
    return false;
  }

  static private boolean jj_3R_145() {
    if (jj_3R_193()) return true;
    return false;
  }

  static private boolean jj_3R_214() {
    if (jj_scan_token(NONREFLEXIVETRASITIVECLOSURE)) return true;
    return false;
  }

  static private boolean jj_3R_173() {
    if (jj_scan_token(IDEN)) return true;
    return false;
  }

  static private boolean jj_3_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    if (jj_3R_82()) return true;
    return false;
  }

  static private boolean jj_3_21() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    if (jj_3R_82()) return true;
    return false;
  }

  static private boolean jj_3_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    if (jj_3R_82()) return true;
    return false;
  }

  static private boolean jj_3R_213() {
    if (jj_scan_token(REFLEXIVETRASITIVECLOSURE)) return true;
    return false;
  }

  static private boolean jj_3R_172() {
    if (jj_scan_token(NONE)) return true;
    return false;
  }

  static private boolean jj_3R_212() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  static private boolean jj_3_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    if (jj_3R_82()) return true;
    return false;
  }

  static private boolean jj_3_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    if (jj_3R_82()) return true;
    return false;
  }

  static private boolean jj_3R_95() {
    if (jj_scan_token(NUM)) return true;
    return false;
  }

  static private boolean jj_3R_66() {
    if (jj_scan_token(POUND)) return true;
    return false;
  }

  static private boolean jj_3R_199() {
    if (jj_scan_token(SEQ)) return true;
    return false;
  }

  static private boolean jj_3R_179() {
    if (jj_3R_206()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_241() {
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_86() {
    if (jj_scan_token(NO)) return true;
    return false;
  }

  static private boolean jj_3R_240() {
    if (jj_3R_206()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_238() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_240()) {
    jj_scanpos = xsp;
    if (jj_3R_241()) return true;
    }
    return false;
  }

  static private boolean jj_3_35() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    if (jj_3R_82()) return true;
    return false;
  }

  static private boolean jj_3R_178() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  static private boolean jj_3R_84() {
    if (jj_3R_142()) return true;
    if (jj_3R_87()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_143()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_58() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  static private boolean jj_3R_180() {
    if (jj_3R_207()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_85() {
    if (jj_3R_144()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_192() {
    if (jj_3R_214()) return true;
    return false;
  }

  static private boolean jj_3R_191() {
    if (jj_3R_213()) return true;
    return false;
  }

  static private boolean jj_3R_190() {
    if (jj_3R_212()) return true;
    return false;
  }

  static private boolean jj_3R_189() {
    if (jj_3R_66()) return true;
    return false;
  }

  static private boolean jj_3R_188() {
    if (jj_3R_199()) return true;
    return false;
  }

  static private boolean jj_3R_187() {
    if (jj_3R_159()) return true;
    return false;
  }

  static private boolean jj_3_39() {
    if (jj_3R_82()) return true;
    if (jj_3R_92()) return true;
    return false;
  }

  static private boolean jj_3R_186() {
    if (jj_3R_58()) return true;
    return false;
  }

  static private boolean jj_3R_144() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3_38() {
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3_23() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3_37() {
    if (jj_3R_82()) return true;
    return false;
  }

  static private boolean jj_3R_239() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_36()) {
    jj_scanpos = xsp;
    if (jj_3_37()) return true;
    }
    return false;
  }

  static private boolean jj_3R_169() {
    if (jj_scan_token(UNSIGNEDRIGHTSHIFT)) return true;
    return false;
  }

  static private boolean jj_3_36() {
    if (jj_3R_87()) return true;
    if (jj_3R_93()) return true;
    return false;
  }

  static private boolean jj_3R_168() {
    if (jj_scan_token(RIGHTSHIFT)) return true;
    return false;
  }

  static private boolean jj_3R_167() {
    if (jj_scan_token(LEFTSHIFT)) return true;
    return false;
  }

  static private boolean jj_3R_135() {
    if (jj_3R_138()) return true;
    return false;
  }

  static private boolean jj_3R_134() {
    if (jj_3R_181()) return true;
    if (jj_3R_239()) return true;
    return false;
  }

  static private boolean jj_3R_80() {
    if (jj_scan_token(DOT)) return true;
    return false;
  }

  static private boolean jj_3R_133() {
    if (jj_scan_token(LET)) return true;
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3_34() {
    if (jj_3R_90()) return true;
    if (jj_3R_82()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_22()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_92()) return true;
    return false;
  }

  static private boolean jj_3R_75() {
    if (jj_scan_token(RANGERESTRICTION)) return true;
    return false;
  }

  static private boolean jj_3_33() {
    if (jj_3R_89()) return true;
    if (jj_3R_82()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_21()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_92()) return true;
    return false;
  }

  static private boolean jj_3_32() {
    if (jj_3R_88()) return true;
    if (jj_3R_82()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_20()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_92()) return true;
    return false;
  }

  static private boolean jj_3_31() {
    if (jj_3R_86()) return true;
    if (jj_3R_82()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_19()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_92()) return true;
    return false;
  }

  static private boolean jj_3R_73() {
    if (jj_scan_token(DOMAINRESTRICTION)) return true;
    return false;
  }

  static private boolean jj_3_30() {
    if (jj_3R_91()) return true;
    if (jj_3R_82()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_18()) { jj_scanpos = xsp; break; }
    }
    if (jj_3R_92()) return true;
    return false;
  }

  static private boolean jj_3_29() {
    if (jj_3R_90()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_68() {
    if (jj_scan_token(PLUSPLUS)) return true;
    return false;
  }

  static private boolean jj_3_28() {
    if (jj_3R_89()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3_27() {
    if (jj_3R_88()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_171() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  static private boolean jj_3_25() {
    if (jj_3R_85()) return true;
    return false;
  }

  static private boolean jj_3_26() {
    if (jj_3R_86()) return true;
    if (jj_3R_87()) return true;
    return false;
  }

  static private boolean jj_3R_170() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  static private boolean jj_3R_132() {
    if (jj_3R_180()) return true;
    return false;
  }

  static private boolean jj_3_24() {
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_237() {
    if (jj_3R_87()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_142() {
    if (jj_scan_token(IMPLIES)) return true;
    return false;
  }

  static private boolean jj_3R_131() {
    if (jj_3R_179()) return true;
    return false;
  }

  static private boolean jj_3R_78() {
    if (jj_3R_120()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(24)) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_128() {
    if (jj_3R_177()) return true;
    if (jj_3R_138()) return true;
    return false;
  }

  static private boolean jj_3R_130() {
    if (jj_3R_178()) return true;
    if (jj_3R_238()) return true;
    return false;
  }

  static private boolean jj_3R_236() {
    if (jj_scan_token(IFF)) return true;
    return false;
  }

  static private boolean jj_3R_127() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_87()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  static private boolean jj_3R_129() {
    if (jj_scan_token(LBRACKET)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_237()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_126() {
    if (jj_3R_176()) return true;
    return false;
  }

  static private boolean jj_3R_125() {
    if (jj_3R_175()) return true;
    return false;
  }

  static private boolean jj_3R_52() {
    if (jj_scan_token(DOUBLEIMPLIES)) return true;
    return false;
  }

  static private boolean jj_3R_124() {
    if (jj_3R_174()) return true;
    return false;
  }

  static private boolean jj_3R_123() {
    if (jj_3R_173()) return true;
    return false;
  }

  static private boolean jj_3R_50() {
    if (jj_scan_token(OR)) return true;
    return false;
  }

  static private boolean jj_3R_122() {
    if (jj_3R_172()) return true;
    return false;
  }

  static private boolean jj_3R_81() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3_25()) {
    jj_scanpos = xsp;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3_27()) {
    jj_scanpos = xsp;
    if (jj_3_28()) {
    jj_scanpos = xsp;
    if (jj_3_29()) {
    jj_scanpos = xsp;
    if (jj_3_30()) {
    jj_scanpos = xsp;
    if (jj_3_31()) {
    jj_scanpos = xsp;
    if (jj_3_32()) {
    jj_scanpos = xsp;
    if (jj_3_33()) {
    jj_scanpos = xsp;
    if (jj_3_34()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) {
    jj_scanpos = xsp;
    if (jj_3R_134()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_121() {
    if (jj_3R_95()) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public ParserTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[95];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x2000,0x100000,0xc000,0xc000,0x4000,0x400000,0x2000000,0x2000000,0x4000,0x200000,0x400000,0x80000,0x1000000,0x74000,0x74000,0xfc000000,0x0,0x0,0x0,0x0,0x0,0x100000,0x0,0x1000000,0x4000,0x1000000,0x0,0x0,0xfc475000,0x0,0xfc000000,0xfc000000,0x0,0x0,0xfc475000,0x1000000,0xfc475000,0x1000000,0x1000000,0x1000000,0x1000000,0x1000000,0x1000000,0x1000000,0xfc471000,0x0,0x4000,0xfc475000,0x1000000,0x0,0xfc475000,0x4000,0xfc475000,0x4000,0xfc475000,0x0,0x400000,0x104000,0x1000000,0x800000,0x0,0xfc475000,0x0,0x400000,0x104000,0x1000000,0x800000,0x0,0xfc475000,0x4000,0x0,0x0,0xfc475000,0x4000,0x201000,0x0,0x201000,0x0,0x200000,0x24000,0xc00,0x1000000,0x0,0x1004000,0x1000000,0x8000000,0x104000,0x1000000,0xfc475000,0x0,0x0,0x0,0x74000,0x74000,0x8000000,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x0,0xe,0xe,0xe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1e,0x1e,0x7fde0,0x7c80010,0x30000000,0x0,0x8000000,0x0,0x0,0x0,0x8000000,0x80000000,0x37fffffe,0x200,0x80000,0x0,0x70000,0xc00,0x37fffffe,0x0,0x37fffffe,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100000,0x7fde0,0x0,0xb7fffffe,0x0,0x0,0x37fffffe,0x0,0x37fffffe,0x0,0x37fffffe,0x0,0x0,0x8000000,0x0,0x0,0x0,0x37fffffe,0x0,0x0,0x8000000,0x0,0x0,0x0,0x37fffffe,0x0,0x0,0x0,0x37fffffe,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0xe,0x0,0x0,0x0,0x8000000,0x0,0x37fffffe,0x0,0xe,0x400,0x0,0x400,0x0,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x0,0x5c7e00,0x5c7e00,0x5c7e00,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x0,0x400000,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x1,0x4000dd,0x100,0x0,0x0,0x0,0x0,0x4000dd,0x0,0x4000dd,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xd8,0x0,0x400005,0x4000dd,0x0,0x100,0x4000dd,0x400000,0x4000dd,0x400000,0x4000dd,0x10,0x0,0x400000,0x0,0x0,0x20,0x4000dd,0x10,0x0,0x400000,0x0,0x0,0x20,0x4000dd,0x400000,0x8000,0x6000,0x4000dd,0x400001,0x0,0x20000,0x0,0x20000,0x0,0x400000,0x0,0x0,0x100000,0x400000,0x0,0x200000,0x400000,0x0,0x4000dd,0x1,0x100000,0x0,0x400000,0x400000,0x200000,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[44];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public Parser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public Parser(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public Parser(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public Parser(ParserTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 95; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[87];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 95; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 87; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 44; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}

// Classes defining the Abstract Syntax Tree

abstract class Exp {}
class Num extends Exp {
    int value;
    Num(int v) {value = v;}
    public String toString() {return value + "";}
}
class Id extends Exp {
        String value;
        Id(String v) {value = v;}
        public String toString() {return value + "";}
}
class Module extends Exp{
        String value;
    Module(String v) {value = v;}
    public String toString() {return value + "";}
}
class This extends Exp{
        String value;
    This(String v) {value = v;}
    public String toString() {return value + "";}
}
class Stroke extends Exp{
        String value;
    Stroke(String v) {value = v;}
    public String toString() {return value + "";}
}
class LBracket extends Exp{
        String value;
    LBracket(String v) {value = v;}
    public String toString() {return value + "";}
}
class RBracket extends Exp{
        String value;
    RBracket(String v) {value = v;}
    public String toString() {return value + "";}
}
class Exactly extends Exp{
        String value;
    Exactly(String v) {value = v;}
    public String toString() {return value + "";}
}
class BinaryExp extends Exp {
    Exp op;
    Exp left, right;
    BinaryExp() {};
    BinaryExp(Exp o, Exp l, Exp r) {op = o; left = l; right = r;}
    public void setOp(Exp o) {op = o;}
    public void setLeft(Exp e) {left = e;}
    public void setRight(Exp e) {right = e;}
    public String toString() {return "(" + op + " " + left + " " + right + ")";}
}
class UnaryExp extends Exp {
    Exp op;
    Exp exp;
    UnaryExp(){}
    UnaryExp(Exp o, Exp e) {op = o; exp = e;}
    public void setOp(Exp o) {op = o;}
    public void setExp(Exp e) {exp = e;}
    public String toString() {return "(" + op + " " + exp + ")";}
}
class Specification extends Exp{
        Exp mdecl;
        List<Exp> odecl_list;
        List<Exp> paragraph_list;
        Specification() { odecl_list = new ArrayList<Exp>(); paragraph_list = new ArrayList<Exp>();}
        public void addOpenDecl(Exp o) {odecl_list.add(o);}
        public void addParagraph(Exp f) {paragraph_list.add(f);}
        public void setModule(Exp m) {mdecl = m;}
        public String toString()
        {
                String s = "(Specification \u005cn";
                if(mdecl != null){
                        s += mdecl + "\u005cn";
                }
                for(int i = 0; i <odecl_list.size(); ++i){
                        s += odecl_list.get(i).toString() + "\u005cn";
                }
                for(int i = 0; i <paragraph_list.size(); ++i){
                        s += paragraph_list.get(i).toString() + "\u005cn";
                }
                s += ")";
                return s;
        }
}
class ModuleDeclaration extends Exp{
        String name;
        ModuleDeclaration(String n) {name = n;}
        public String toString() {return "(Module: " + name + " )";}
}
class Open extends Exp{
        String value;
        Open(String v) {value = v;}
        public String toString() {return value + "";}
}
class Univ extends Exp{
        String value;
        Univ(String v) {value = v;}
        public String toString() {return value + "";}
}
class Int extends Exp{
        String value;
        Int(String v) {value = v;}
        public String toString() {return value + "";}
}
class Seqint extends Exp{
        String value;
        Seqint(String v) {value = v;}
        public String toString() {return value + "";}
}
class As extends Exp{
        String value;
        As(String v) {value = v;}
        public String toString() {return value + "";}
}
class Private extends Exp{
        String value;
        Private(String v) {value = v;}
        public String toString() {return value + "";}
}
class Comma extends Exp{
        String value;
        Comma(String v) {value = v;}
        public String toString() {return value + "";}
}
class OpenDeclaration extends Exp{
        String name;
        OpenDeclaration(String n) {name = n;}
        public String toString() {return "(Open " + name + ")";}
}
class EqualSign extends Exp{
        String value;
        EqualSign(String v) {value = v;}
        public String toString() {return value + "";}
}
class Inclusion extends Exp{
        String value;
        Inclusion(String v) {value = v;}
        public String toString() {return value + "";}
}
class Lesser extends Exp{
        String value;
        Lesser(String v) {value = v;}
        public String toString() {return value + "";}
}
class Greater extends Exp{
        String value;
        Greater(String v) {value = v;}
        public String toString() {return value + "";}
}
class LesserOrEqual extends Exp{
        String value;
        LesserOrEqual(String v) {value = v;}
        public String toString() {return value + "";}
}
class GreaterOrEqual extends Exp{
        String value;
        GreaterOrEqual(String v) {value = v;}
        public String toString() {return value + "";}
}
class Arrow extends Exp{
        String value;
        Arrow(String v) {value = v;}
        public String toString() {return value + "";}
}
class ArrowOpExp extends Exp{
        Exp left;
        Exp right;
        Exp arrow;
        ArrowOpExp() {}
        public void setLeft(Exp l) {left = l;}
        public void setRight(Exp r) {right = r;}
        public void setArrow(Exp a) {arrow = a;}
        public String toString() {
                String s = "( " + arrow;
                if(left != null){
                        s += " " + left + " ";
                }
                if(right != null){
                        s += " " + right + " ";
                }
                s += " )";
                return s;
        }
}
class Some extends Exp{
        String value;
        Some(String v) {value = v;}
        public String toString() {return value + "";}
}
class One extends Exp{
        String value;
        One(String v) {value = v;}
        public String toString() {return value + "";}
}
class Lone extends Exp{
        String value;
        Lone(String v) {value = v;}
        public String toString() {return value + "";}
}
class Set extends Exp{
        String value;
        Set(String v) {value = v;}
        public String toString() {return value + "";}
}
class Or extends Exp{
        String value;
        Or(String v) {value = v;}
        public String toString() {return value + "";}
}
class And extends Exp{
        String value;
        And(String v) {value = v;}
        public String toString() {return value + "";}
}
class DoubleImplication extends Exp{
        String value;
        DoubleImplication(String v) {value = v;}
        public String toString() {return value + "";}
}
class Iff extends Exp{
        String value;
        Iff(String v) {value = v;}
        public String toString() {return value + "";}
}
class Implies extends Exp{
        String value;
        Implies(String v) {value = v;}
        public String toString() {return value + "";}
}
class Plus extends Exp{
        String value;
        Plus(String v) {value = v;}
        public String toString() {return value + "";}
}
class Minus extends Exp{
        String value;
        Minus(String v) {value = v;}
        public String toString() {return value + "";}
}
class PlusPlus extends Exp{
        String value;
        PlusPlus(String v) {value = v;}
        public String toString() {return value + "";}
}
class DomainRestriction extends Exp{
        String value;
        DomainRestriction(String v) {value = v;}
        public String toString() {return value + "";}
}
class RangeRestriction extends Exp{
        String value;
        RangeRestriction(String v) {value = v;}
        public String toString() {return value + "";}
}
class Dot extends Exp{
        String value;
        Dot(String v) {value = v;}
        public String toString() {return value + "";}
}
class LeftShift extends Exp{
        String value;
        LeftShift(String v) {value = v;}
        public String toString() {return value + "";}
}
class RightShift extends Exp{
        String value;
        RightShift(String v) {value = v;}
        public String toString() {return value + "";}
}
class UnsignedRightShift extends Exp{
        String value;
        UnsignedRightShift(String v) {value = v;}
        public String toString() {return value + "";}
}
class Bang extends Exp{
        String value;
        Bang(String v) {value = v;}
        public String toString() {return value + "";}
}
class Not extends Exp{
        String value;
        Not(String v) {value = v;}
        public String toString() {return value + "";}
}
class No extends Exp{
        String value;
        No(String v) {value = v;}
        public String toString() {return value + "";}
}
class Seq extends Exp{
        String value;
        Seq(String v) {value = v;}
        public String toString() {return value + "";}
}
class Pound extends Exp{
        String value;
        Pound(String v) {value = v;}
        public String toString() {return value + "";}
}
class Tilde extends Exp{
        String value;
        Tilde(String v) {value = v;}
        public String toString() {return value + "";}
}
class ReflexiveTransitiveClosure extends Exp{
        String value;
        ReflexiveTransitiveClosure(String v) {value = v;}
        public String toString() {return value + "";}
}
class NonReflexiveTransitiveClosure extends Exp{
        String value;
        NonReflexiveTransitiveClosure(String v) {value = v;}
        public String toString() {return value + "";}
}
class Disjoint extends Exp{
        String value;
        Disjoint(String v) {value = v;}
        public String toString() {return value + "";}
}
class All extends Exp{
        String value;
        All(String v) {value = v;}
        public String toString() {return value + "";}
}
class Sum extends Exp{
        String value;
        Sum(String v) {value = v;}
        public String toString() {return value + "";}
}
class Let extends Exp{
        Exp name;
        Exp op;
        Exp expr;
        Let() {}
        public void setName(Exp n) {name = n;}
        public void setOp(Exp o) {op = o;}
        public void setExpr(Exp e) {expr = e;}
        public String toString() {return "( " + name + " " + op + " " + expr + " )";}
}
class Colon extends Exp{
        String value;
        Colon(String v) {value = v;}
        public String toString() {return value + "";}
}
class LetSym extends Exp{
        String value;
        LetSym(String v) {value = v;}
        public String toString() {return value + "";}
}
class Decl extends Exp{
        Exp qualifier;
        Exp disjName;
        Exp name;
        Exp op;
        Exp disjExpr;
        Exp expr;
        Decl() {}
        public void setQualifier(Exp q) {qualifier = q;}
        public void setDisjName(Exp dn) {disjName = dn;}
        public void setName(Exp n) {name = n;}
        public void setOp(Exp o) {op = o;}
        public void setDisjExpr(Exp de) {disjExpr = de;}
        public void setExpr(Exp e) {expr = e;}
        public String toString() {
                String s = "( ";
                if(qualifier != null){
                        s += qualifier + " ";
                }
                if(disjName != null){
                        s += disjName + " ";
                }
                s += name + " ";
                s += op + " ";
                if(disjExpr != null){
                        s += disjName + " ";
                }
                s += expr;
                s += ")";
                return s;
        }
}
class Bar extends Exp{
        String value;
        Bar(String v) {value = v;}
        public String toString() {return value + "";}
}
class BlockOrBar extends Exp{
        Exp block;
        Exp op;
        Exp expr;
        BlockOrBar() {}
        public void setBlock(Exp bl) {block = bl;}
        public void setBar(Exp o, Exp e) {op = o; expr = e;}
        public String toString() {
                String s;
                s = "( ";
                if(block != null){
                        s += block + " ";
                }
                else if(op != null){
                        s += op + " " + expr + " ";
                }
                s+= ")";
                return s;
        }
}
class Lcurly extends Exp{
        String value;
        Lcurly(String v) {value = v;}
        public String toString() {return value + "";}
}
class Rcurly extends Exp{
        String value;
        Rcurly(String v) {value = v;}
        public String toString() {return value + "";}
}
class Block extends Exp{
        Exp expr;
        Block(){}
        public void setExpr(Exp e){expr = e;}
        public String toString() {return "( " + expr + " )";}
}
class Iden extends Exp{
        String value;
        Iden(String v) {value = v;}
        public String toString() {return value + "";}
}
class None extends Exp{
        String value;
        None(String v) {value = v;}
        public String toString() {return value + "";}
}
class Lparen extends Exp{
        String value;
        Lparen(String v) {value = v;}
        public String toString() {return value + "";}
}
class Rparen extends Exp{
        String value;
        Rparen(String v) {value = v;}
        public String toString() {return value + "";}
}
class At extends Exp{
        String value;
        At(String v) {value = v;}
        public String toString() {return value + "";}
}
class Else extends Exp{
        String value;
        Else(String v) {value = v;}
        public String toString() {return value + "";}
}
class Run extends Exp{
        String value;
        Run(String v) {value = v;}
        public String toString() {return value + "";}
}
class Check extends Exp{
        String value;
        Check(String v) {value = v;}
        public String toString() {return value + "";}
}
class For extends Exp{
        String value;
        For(String v) {value = v;}
        public String toString() {return value + "";}
}
class But extends Exp{
        String value;
        But(String v) {value = v;}
        public String toString() {return value + "";}
}
class Abstract extends Exp{
        String value;
        Abstract(String v) {value = v;}
        public String toString() {return value + "";}
}
class Expect extends Exp{
        String value;
        Expect(String v) {value = v;}
        public String toString() {return value + "";}
}
class Zero extends Exp{
        String value;
        Zero(String v) {value = v;}
        public String toString() {return value + "";}
}
class OneDigit extends Exp{
        String value;
        OneDigit(String v) {value = v;}
        public String toString() {return value + "";}
}
class LetExpr extends Exp{
        Exp op;
        List<Exp> letDeclList;
        Exp blockOrBar;
        LetExpr(){}
        public void setOp(Exp o){op = o;}
        public void addletDecl(Exp l){letDeclList.add(l);}
        public void setBlockOrBar(Exp b){blockOrBar = b;}
        public String toString()
        {
                String s;
                s = "( ";
                s += op + " ";
                for(int i = 0; i < letDeclList.size(); i++){
                        s +=  letDeclList.get(i).toString() + " ";
                }
                s += blockOrBar + " )";
                return s;
        }
}
class DeclExpr extends Exp{
        Exp quant;
        List<Exp> declList;
        Exp blockOrBar;
        DeclExpr(){}
        public void setQuant(Exp q){quant = q;}
        public void addDecl(Exp d){declList.add(d);}
        public void setBlockOrBar(Exp b){blockOrBar = b;}
        public String toString()
        {
                String s;
                s = "( ";
                s += quant;
                for(int i = 0; i < declList.size(); i++){
                        s +=  declList.get(i).toString() + " ";
                }
                s += blockOrBar + " )";
                return s;
        }
}
class CurlyExpr extends Exp{
        Exp lop;
        Exp rop;
        List<Exp> declList;
        Exp blockOrBar;
        CurlyExpr(){}
        public void setLeftOp(Exp l){lop = l;}
        public void setRightOp(Exp r){rop = r;}
        public void addDecl(Exp d){declList.add(d);}
        public void setBlockOrBar(Exp b){blockOrBar = b;}
        public String toString()
        {
                String s;
                s = "( ";
                s += lop;
                for(int i = 0; i < declList.size(); i++){
                        s +=  declList.get(i).toString() + " ";
                }
                s += blockOrBar + " " + rop + " )";
                return s;
        }
}
class UnOpExpr extends Exp{
        Exp unop;
        Exp expr;
        UnOpExpr(){}
        public void setUnOp(Exp u){unop = u;}
        public void setExpr(Exp e){expr = e;}
        public String toString(){return "(Unary Operator "+ unop + " "+ expr + ")";}
}

class Fact extends Exp{
        Exp name;
        List<Exp> block;
        Fact(){block = new ArrayList<Exp>();}
        public void setName(Exp n){name = n;}
        public void addBlock(Exp b){block.add(b);}
        public String toString(){
                String s = "(Fact ";
                if(name != null){
                        s += name + " ";
                }
                for(int i = 0; i < block.size(); i++){
            s +=  block.get(i).toString() + " ";
        }
                s += " )";
                return s;
        }
}
class Assert extends Exp{
        Exp name;
        Exp block;
        Assert(){}
        public void setName(Exp n){name = n;}
        public void setBlock(Exp b){block = b;}
        public String toString(){
                String s = "(Assert ";
                if(name != null){
                        s += name + " ";
                }
                s += block + " )";
                return s;
        }
}
class Function extends Exp{
    boolean isPred;
        Exp qualifier;
        Exp ref;
        Exp name;
        List<Exp> arguments;
        Exp expr;
        List<Exp> block;
        Function(){arguments = new ArrayList<Exp>(); block = new ArrayList<Exp>(); isPred = false;}
        public void setQualifier(Exp q){qualifier = q;}
        public void setRef(Exp r){ref = r;}
        public void setName(Exp n){name = n;}
        public void addArguments(Exp a){arguments.add(a);}
        public void addBlock(Exp b){block.add(b);}
        public void setExpr(Exp e){expr = e;}
        public void setPredTrue() {isPred = true;};
        public String toString(){
                String s = "(Function ";
                if(qualifier != null){
                        s+= qualifier + " ";
                }
                if(ref != null){
                        s+= ref + " ";
                }
                s += name + " ";
                for(int i = 0; i < arguments.size(); i++){
                        s +=  arguments.get(i).toString() + " ";
                }
                if(expr != null){
                        s += "( "+ expr + " )";
                }
                for(int i = 0; i < block.size(); i++){
            s +=  block.get(i).toString() + " ";
        }
        s += ")";
                return s;
        }
}
class Command extends Exp{
        Exp name;
        Exp type;
        Exp qualname;
        Exp scope;
        Command(){}
        public void setQualName(Exp q){qualname = q;}
        public void setType(Exp r){type = r;}
        public void setName(Exp n){name = n;}
        public void setScope(Exp e){scope = e;}
        public String toString(){
                String s = "(Command ";
                if(name != null){
                        s+= name + " ";
                }
                s+= type + " ";
                s += qualname + " ";
                s += scope + " )";
                return s;
        }
}
class Enum extends Exp{
        Exp name;
        List<Exp> bodyList;
        Enum(){bodyList = new ArrayList<Exp>();}
        public void setName(Exp n){name = n;}
        public void addBody(Exp a){bodyList.add(a);}
        public String toString(){
                String s = "(Enum ";
                s += name + "( ";
                for(int i = 0; i < bodyList.size(); i++){
                        s +=  bodyList.get(i).toString() + ", ";
                }
                s += " ) )";
                return s;
        }
}
class Signature extends Exp{
        List<Exp> qualifierList;
        Exp name;
        Exp parentClass;
        Exp wholeClass;
        Boolean extension;
        Boolean composition;
        List<Exp> bodyList;
        List<Exp> blockList;
        Signature(){
            qualifierList = new ArrayList<Exp>();
            bodyList = new ArrayList<Exp>();
            blockList = new ArrayList<Exp>();
            extension = false;
            composition = false;
        }
        public void addQualifier(Exp a){qualifierList.add(a);}
        public void setName(Exp n){name = n;}
        public void setParentClass(Exp p){parentClass = p;}
        public void setWholeClass(Exp p){wholeClass = p;}
        public void addBody(Exp a){bodyList.add(a);}
        public void addBlock(Exp b){blockList.add(b);}
        public String toString(){
                String s = "(Signature ";
                for(int i = 0; i < qualifierList.size(); i++){
                        s +=  qualifierList.get(i).toString() + ", ";
                }
                s += name + "( ";
                if(parentClass != null){
                s += "(parent class: " + parentClass + ") ";
                }
                for(int i = 0; i < bodyList.size(); i++){
                        s +=  bodyList.get(i).toString() + ", ";
                }
                for(int i = 0; i < blockList.size(); i++){
                        s += blockList.get(i).toString() + ", ";
                }
                s += " ) )";
                return s;
        }
}
